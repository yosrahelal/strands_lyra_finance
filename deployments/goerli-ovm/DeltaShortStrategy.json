{
  "address": "0xc5a5C42992dECbae36851359345FE25997F5C42d",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract LyraVault",
          "name": "_vault",
          "type": "address"
        },
        {
          "internalType": "enum LyraAdapter.OptionType",
          "name": "_optionType",
          "type": "uint8"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "thrower",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "baseExpected",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "baseReceived",
          "type": "uint256"
        }
      ],
      "name": "ExchangerBaseReceivedTooLow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "thrower",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "quoteExpected",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "quoteReceived",
          "type": "uint256"
        }
      ],
      "name": "ExchangerQuoteReceivedTooLow",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        }
      ],
      "name": "_isValidExpiry",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "activeExpiry",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "activeStrikeIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseAsset",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "collateralAsset",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "curveSwap",
      "outputs": [
        {
          "internalType": "contract ICurve",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "strikeId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "lyraRewardRecipient",
          "type": "address"
        }
      ],
      "name": "doTrade",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "premiumReceived",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collateralToAdd",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "lyraRewardRecipient",
          "type": "address"
        }
      ],
      "name": "emergencyCloseAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeCounter",
      "outputs": [
        {
          "internalType": "contract BasicFeeCounter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "positionId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikeId",
              "type": "uint256"
            },
            {
              "internalType": "enum LyraAdapter.OptionType",
              "name": "optionType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateral",
              "type": "uint256"
            },
            {
              "internalType": "enum LyraAdapter.PositionState",
              "name": "state",
              "type": "uint8"
            }
          ],
          "internalType": "struct LyraAdapter.OptionPosition",
          "name": "position",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "strikePrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "strikeExpiry",
          "type": "uint256"
        }
      ],
      "name": "getAllowedCloseAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "closeAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "skew",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "boardIv",
              "type": "uint256"
            }
          ],
          "internalType": "struct LyraAdapter.Strike",
          "name": "strike",
          "type": "tuple"
        }
      ],
      "name": "getRequiredCollateral",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "collateralToAdd",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "setCollateralTo",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "greekCache",
      "outputs": [
        {
          "internalType": "contract IOptionGreekCache",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gwavOracle",
      "outputs": [
        {
          "internalType": "contract IGWAVOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_lyraRegistry",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_optionMarket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_curveSwap",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_feeCounter",
          "type": "address"
        }
      ],
      "name": "initAdapter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "skew",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "boardIv",
              "type": "uint256"
            }
          ],
          "internalType": "struct LyraAdapter.Strike",
          "name": "strike",
          "type": "tuple"
        }
      ],
      "name": "isValidStrike",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "lastTradeTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidityPool",
      "outputs": [
        {
          "internalType": "contract ILiquidityPool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lyraRegistry",
      "outputs": [
        {
          "internalType": "contract ILyraRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionMarket",
      "outputs": [
        {
          "internalType": "contract IOptionMarket",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionPricer",
      "outputs": [
        {
          "internalType": "contract IOptionMarketPricer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionToken",
      "outputs": [
        {
          "internalType": "contract IOptionToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionType",
      "outputs": [
        {
          "internalType": "enum LyraAdapter.OptionType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "quoteAsset",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "closeAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "lyraRewardRecipient",
          "type": "address"
        }
      ],
      "name": "reducePosition",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "returnFundsAndClearStrikes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "boardId",
          "type": "uint256"
        }
      ],
      "name": "setBoard",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_lyraRegistry",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_optionMarket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_curveSwap",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_feeCounter",
          "type": "address"
        }
      ],
      "name": "setLyraAddresses",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "minTimeToExpiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxTimeToExpiry",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "targetDelta",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "maxDeltaGap",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minVol",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxVol",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "size",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minTradeInterval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxVolVariance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gwavPeriod",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collatBuffer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collatPercent",
              "type": "uint256"
            }
          ],
          "internalType": "struct DeltaShortStrategy.DeltaShortStrategyDetail",
          "name": "_deltaStrategy",
          "type": "tuple"
        }
      ],
      "name": "setStrategyDetail",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "shortCollateral",
      "outputs": [
        {
          "internalType": "contract IShortCollateral",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strategyDetail",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "minTimeToExpiry",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxTimeToExpiry",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "targetDelta",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "maxDeltaGap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minVol",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxVol",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "size",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minTradeInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxVolVariance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gwavPeriod",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collatBuffer",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collatPercent",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "strikeToPositionId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "updateDelegateApproval",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vault",
      "outputs": [
        {
          "internalType": "contract LyraVault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x7e1dfe338b1470c92122df102bb372fdf30661ed4063d61ada53c956a597e6a2",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xc5a5C42992dECbae36851359345FE25997F5C42d",
    "transactionIndex": 0,
    "gasUsed": "4396358",
    "logsBloom": "0x00000000000000000000000000000000000004000000000000800000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000100000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000200000000000000000000000002000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2d2a1591a26a00141aad613d1daa0646c47da902ad29c2c3efdea9b0264c56bd",
    "transactionHash": "0x7e1dfe338b1470c92122df102bb372fdf30661ed4063d61ada53c956a597e6a2",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 449516,
        "transactionHash": "0x7e1dfe338b1470c92122df102bb372fdf30661ed4063d61ada53c956a597e6a2",
        "address": "0xc5a5C42992dECbae36851359345FE25997F5C42d",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x2d2a1591a26a00141aad613d1daa0646c47da902ad29c2c3efdea9b0264c56bd"
      }
    ],
    "blockNumber": 449516,
    "cumulativeGasUsed": "4396358",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x09635F643e140090A9A8Dcd712eD6285858ceBef",
    4
  ],
  "numDeployments": 1,
  "solcInputHash": "da1b2efd2c033d4948af2192ee20b985",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract LyraVault\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"enum LyraAdapter.OptionType\",\"name\":\"_optionType\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"thrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseExpected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseReceived\",\"type\":\"uint256\"}],\"name\":\"ExchangerBaseReceivedTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"thrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quoteExpected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteReceived\",\"type\":\"uint256\"}],\"name\":\"ExchangerQuoteReceivedTooLow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"_isValidExpiry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeStrikeIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveSwap\",\"outputs\":[{\"internalType\":\"contract ICurve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strikeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lyraRewardRecipient\",\"type\":\"address\"}],\"name\":\"doTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premiumReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralToAdd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lyraRewardRecipient\",\"type\":\"address\"}],\"name\":\"emergencyCloseAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCounter\",\"outputs\":[{\"internalType\":\"contract BasicFeeCounter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeId\",\"type\":\"uint256\"},{\"internalType\":\"enum LyraAdapter.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"enum LyraAdapter.PositionState\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct LyraAdapter.OptionPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeExpiry\",\"type\":\"uint256\"}],\"name\":\"getAllowedCloseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"closeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boardIv\",\"type\":\"uint256\"}],\"internalType\":\"struct LyraAdapter.Strike\",\"name\":\"strike\",\"type\":\"tuple\"}],\"name\":\"getRequiredCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralToAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setCollateralTo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"greekCache\",\"outputs\":[{\"internalType\":\"contract IOptionGreekCache\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gwavOracle\",\"outputs\":[{\"internalType\":\"contract IGWAVOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lyraRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optionMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveSwap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeCounter\",\"type\":\"address\"}],\"name\":\"initAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boardIv\",\"type\":\"uint256\"}],\"internalType\":\"struct LyraAdapter.Strike\",\"name\":\"strike\",\"type\":\"tuple\"}],\"name\":\"isValidStrike\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTradeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPool\",\"outputs\":[{\"internalType\":\"contract ILiquidityPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lyraRegistry\",\"outputs\":[{\"internalType\":\"contract ILyraRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionMarket\",\"outputs\":[{\"internalType\":\"contract IOptionMarket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionPricer\",\"outputs\":[{\"internalType\":\"contract IOptionMarketPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionToken\",\"outputs\":[{\"internalType\":\"contract IOptionToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionType\",\"outputs\":[{\"internalType\":\"enum LyraAdapter.OptionType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lyraRewardRecipient\",\"type\":\"address\"}],\"name\":\"reducePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnFundsAndClearStrikes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"}],\"name\":\"setBoard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lyraRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optionMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveSwap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeCounter\",\"type\":\"address\"}],\"name\":\"setLyraAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"targetDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeltaGap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTradeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVolVariance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gwavPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatPercent\",\"type\":\"uint256\"}],\"internalType\":\"struct DeltaShortStrategy.DeltaShortStrategyDetail\",\"name\":\"_deltaStrategy\",\"type\":\"tuple\"}],\"name\":\"setStrategyDetail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shortCollateral\",\"outputs\":[{\"internalType\":\"contract IShortCollateral\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTimeToExpiry\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"targetDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeltaGap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTradeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVolVariance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gwavPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collatPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"strikeToPositionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDelegateApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract LyraVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_isValidExpiry(uint256)\":{\"details\":\"check if the expiry of the board is valid according to the strategy\"},\"doTrade(uint256,address)\":{\"details\":\"the vault should pass in a strike id, and the strategy would verify if the strike is valid on-chain.\",\"params\":{\"lyraRewardRecipient\":\"address to receive trading reward. This need to be whitelisted\",\"strikeId\":\"lyra strikeId to trade\"},\"returns\":{\"positionId\":\"positionId\",\"premiumReceived\":\"premiumReceived\"}},\"emergencyCloseAll(address)\":{\"details\":\"close all outstanding positions regardless of collat and send funds back to vault\"},\"getAllowedCloseAmount((uint256,uint256,uint8,uint256,uint256,uint8),uint256,uint256)\":{\"details\":\"calculates the position amount required to stay above the buffer collateral\"},\"getRequiredCollateral((uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"calculate required collateral to add in the next trade. sell size is fixed as strategyDetail.size only add collateral if the additional sell will make the position out of buffer range never remove collateral from an existing position\"},\"isValidStrike((uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"verify if the strike is valid for the strategy\",\"returns\":{\"isValid\":\"true if vol is withint [minVol, maxVol] and delta is within targetDelta +- maxDeltaGap\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"reducePosition(uint256,uint256,address)\":{\"details\":\"use premium in strategy to reduce position size if collateral ratio is out of range\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"returnFundsAndClearStrikes()\":{\"details\":\"convert premium in quote asset into collateral asset and send it back to the vault.\"},\"setBoard(uint256)\":{\"details\":\"set the board id that will be traded for the next round\",\"params\":{\"boardId\":\"lyra board Id.\"}},\"setLyraAddresses(address,address,address,address)\":{\"details\":\"Assigns all lyra contracts\",\"params\":{\"_curveSwap\":\"Curve pool address for swapping sUSD and other stables via `exchange_with_best_rate`\",\"_feeCounter\":\"Fee counter addressu used to determine Lyra trading rewards\",\"_lyraRegistry\":\"LyraRegistry address which holds latest market and global addressess\",\"_optionMarket\":\"OptionMarket address\"}},\"setStrategyDetail((uint256,uint256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"update the strategy detail for the new round.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"doTrade(uint256,address)\":{\"notice\":\"sell a fix aomunt of options and collect premium\"},\"updateDelegateApproval()\":{\"notice\":\"In case of an update to the synthetix contract that revokes the approval\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/DeltaShortStrategy.sol\":\"DeltaShortStrategy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@lyrafinance/protocol/contracts/interfaces/IAddressResolver.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n  function getAddress(bytes32 name) external view returns (address);\\n}\\n\",\"keccak256\":\"0x260e0cd742719bccaa7a070f5fcb94d61e800106750a4f889a2b7a9c157d717b\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ICurve.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface ICurve {\\n  function exchange_with_best_rate(\\n    address _from,\\n    address _to,\\n    uint _amount,\\n    uint _expected,\\n    address _receiver\\n  ) external payable returns (uint amountOut);\\n\\n  function exchange_underlying(\\n    int128 _from,\\n    int128 _to,\\n    uint _amount,\\n    uint _expected\\n  ) external payable returns (uint amountOut);\\n\\n  function get_best_rate(\\n    address _from,\\n    address _to,\\n    uint _amount\\n  ) external view returns (address pool, uint amountOut);\\n}\\n\",\"keccak256\":\"0x016c7fa88dead72662e455bff791dc1898627757876606fc32b2e37f293b6990\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IDelegateApprovals.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface IDelegateApprovals {\\n  function approveExchangeOnBehalf(address delegate) external;\\n\\n  function canExchangeOnBehalf(address exchanger, address beneficiary) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x19f86c5285a5ef5fd5322537d77092dd801caf55ac98f34f5b8b14f172ac36d5\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IExchangeRates.sol\":{\"content\":\"//SPDX-License-Identifier:MIT\\npragma solidity ^0.8.9;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\\ninterface IExchangeRates {\\n  function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\\n}\\n\",\"keccak256\":\"0xf475f01aaa23f721273fc4b91f45589c13c7dad344f8e1d6d5ac84fcae5c316a\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/interfaces/IExchanger.sol\":{\"content\":\"//SPDX-License-Identifier:MIT\\npragma solidity ^0.8.9;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\\ninterface IExchanger {\\n  function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\\n    external\\n    view\\n    returns (uint exchangeFeeRate);\\n}\\n\",\"keccak256\":\"0x977c63c307c4832f4399d77ba9961a295620560f2afc5b2717eaf3cf71f82da6\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/interfaces/IFeeCounter.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface IFeeCounter {\\n  function trackFee(\\n    address market,\\n    address trader,\\n    uint amount,\\n    uint totalCost,\\n    uint totalFee\\n  ) external;\\n}\\n\",\"keccak256\":\"0xf401d58dec60111f52aa3902454d7aa8dcd58b489d69c01bffde67a5aeafeafa\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IGWAVOracle.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\n\\npragma solidity 0.8.9;\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/periphery/GWAVOracle.sol\\\";\\n\\ninterface IGWAVOracle {\\n  function ivGWAV(uint boardId, uint secondsAgo) external view returns (uint);\\n\\n  function skewGWAV(uint strikeId, uint secondsAgo) external view returns (uint);\\n\\n  function volGWAV(uint strikeId, uint secondsAgo) external view returns (uint);\\n\\n  function deltaGWAV(uint strikeId, uint secondsAgo) external view returns (int callDelta);\\n\\n  function vegaGWAV(uint strikeId, uint secondsAgo) external view returns (uint vega);\\n\\n  function optionPriceGWAV(uint strikeId, uint secondsAgo) external view returns (uint callPrice, uint putPrice);\\n}\\n\",\"keccak256\":\"0x15eddfde882a7a9d64e6487e499008d46fd804a03cda7a25a9112d1a5dbc75b1\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ILiquidityPool.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\n\\npragma solidity 0.8.9;\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/LiquidityPool.sol\\\";\\ninterface ILiquidityPool {\\n  struct Collateral {\\n    uint quote;\\n    uint base;\\n  }\\n\\n  /// These values are all in quoteAsset amounts.\\n  struct Liquidity {\\n    // Amount of liquidity available for option collateral and premiums\\n    uint freeLiquidity;\\n    // Amount of liquidity available for withdrawals - different to freeLiquidity\\n    uint burnableLiquidity;\\n    // Amount of liquidity reserved for long options sold to traders\\n    uint usedCollatLiquidity;\\n    // Portion of liquidity reserved for delta hedging (quote outstanding)\\n    uint pendingDeltaLiquidity;\\n    // Current value of delta hedge\\n    uint usedDeltaLiquidity;\\n    // Net asset value, including everything and netOptionValue\\n    uint NAV;\\n  }\\n\\n  struct QueuedDeposit {\\n    uint id;\\n    // Who will receive the LiquidityToken minted for this deposit after the wait time\\n    address beneficiary;\\n    // The amount of quoteAsset deposited to be converted to LiquidityToken after wait time\\n    uint amountLiquidity;\\n    // The amount of LiquidityToken minted. Will equal to 0 if not processed\\n    uint mintedTokens;\\n    uint depositInitiatedTime;\\n  }\\n\\n  struct QueuedWithdrawal {\\n    uint id;\\n    // Who will receive the quoteAsset returned after burning the LiquidityToken\\n    address beneficiary;\\n    // The amount of LiquidityToken being burnt after the wait time\\n    uint amountTokens;\\n    // The amount of quote transferred. Will equal to 0 if process not started\\n    uint quoteSent;\\n    uint withdrawInitiatedTime;\\n  }\\n\\n  struct LiquidityPoolParameters {\\n    // The minimum amount of quoteAsset for a deposit, or the amount of LiquidityToken for a withdrawal\\n    uint minDepositWithdraw;\\n    // Time between initiating a deposit and when it can be processed\\n    uint depositDelay;\\n    // Time between initiating a withdrawal and when it can be processed\\n    uint withdrawalDelay;\\n    // Fee charged on withdrawn funds\\n    uint withdrawalFee;\\n    // Percentage of NAV below which the liquidity CB fires\\n    uint liquidityCBThreshold;\\n    // Length of time after the liq. CB stops firing during which deposits/withdrawals are still blocked\\n    uint liquidityCBTimeout;\\n    // Difference between the spot and GWAV baseline IVs after which point the vol CB will fire\\n    uint ivVarianceCBThreshold;\\n    // Difference between the spot and GWAV skew ratios after which point the vol CB will fire\\n    uint skewVarianceCBThreshold;\\n    // Length of time after the (base) vol. CB stops firing during which deposits/withdrawals are still blocked\\n    uint ivVarianceCBTimeout;\\n    // Length of time after the (skew) vol. CB stops firing during which deposits/withdrawals are still blocked\\n    uint skewVarianceCBTimeout;\\n    // The address of the \\\"guardian\\\"\\n    address guardianMultisig;\\n    // Length of time a deposit/withdrawal since initiation for before a guardian can force process their transaction\\n    uint guardianDelay;\\n    // When a new board is listed, block deposits/withdrawals\\n    uint boardSettlementCBTimeout;\\n    // When exchanging, don't exchange if fee is above this value\\n    uint maxFeePaid;\\n  }\\n\\n  function poolHedger() external view returns (address);\\n\\n  function queuedDeposits(uint id) external view returns (QueuedDeposit memory);\\n\\n  function totalQueuedDeposits() external view returns (uint);\\n\\n  function queuedDepositHead() external view returns (uint);\\n\\n  function nextQueuedDepositId() external view returns (uint);\\n\\n  function queuedWithdrawals(uint id) external view returns (QueuedWithdrawal memory);\\n\\n  function totalQueuedWithdrawals() external view returns (uint);\\n\\n  function queuedWithdrawalHead() external view returns (uint);\\n\\n  function nextQueuedWithdrawalId() external view returns (uint);\\n\\n  function CBTimestamp() external view returns (uint);\\n\\n  /// @dev Amount of collateral locked for outstanding calls and puts sold to users\\n  function lockedCollateral() external view returns (Collateral memory);\\n\\n  /// @dev Total amount of quoteAsset reserved for all settled options that have yet to be paid out\\n  function totalOutstandingSettlements() external view returns (uint);\\n\\n  /// @dev Total value not transferred to this contract for all shorts that didn't have enough collateral after expiry\\n  function insolventSettlementAmount() external view returns (uint);\\n\\n  /// @dev Total value not transferred to this contract for all liquidations that didn't have enough collateral when liquidated\\n  function liquidationInsolventAmount() external view returns (uint);\\n\\n  function initiateDeposit(address beneficiary, uint amountQuote) external;\\n\\n  function initiateWithdraw(address beneficiary, uint amountLiquidityToken) external;\\n\\n  function processDepositQueue(uint limit) external;\\n\\n  function processWithdrawalQueue(uint limit) external;\\n\\n  function updateCBs() external;\\n\\n  function getTotalTokenSupply() external view returns (uint);\\n\\n  function getTokenPriceWithCheck()\\n    external\\n    view\\n    returns (\\n      uint tokenPrice,\\n      bool isStale,\\n      uint circuitBreakerExpiry\\n    );\\n\\n  function getTokenPrice() external view returns (uint);\\n\\n  function getCurrentLiquidity() external view returns (Liquidity memory);\\n\\n  function getLiquidity(uint spotPrice) external view returns (Liquidity memory);\\n\\n  function getTotalPoolValueQuote() external view returns (uint);\\n\\n  function exchangeBase() external;\\n\\n  function getLpParams() external view returns (LiquidityPoolParameters memory);\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /// @dev Emitted whenever the pool paramters are updated\\n  event LiquidityPoolParametersUpdated(LiquidityPoolParameters lpParams);\\n\\n  /// @dev Emitted whenever the poolHedger address is modified\\n  event PoolHedgerUpdated(address poolHedger);\\n\\n  /// @dev Emitted when quote is locked.\\n  event QuoteLocked(uint quoteLocked, uint lockedCollateralQuote);\\n\\n  /// @dev Emitted when quote is freed.\\n  event QuoteFreed(uint quoteFreed, uint lockedCollateralQuote);\\n\\n  /// @dev Emitted when base is locked.\\n  event BaseLocked(uint baseLocked, uint lockedCollateralBase);\\n\\n  /// @dev Emitted when base is freed.\\n  event BaseFreed(uint baseFreed, uint lockedCollateralBase);\\n\\n  /// @dev Emitted when a board is settled.\\n  event BoardSettlement(uint insolventSettlementAmount, uint amountQuoteReserved, uint totalOutstandingSettlements);\\n\\n  /// @dev Emitted when reserved quote is sent.\\n  event OutstandingSettlementSent(address indexed user, uint amount, uint totalOutstandingSettlements);\\n\\n  /// @dev Emitted whenever quote is exchanged for base\\n  event BasePurchased(uint quoteSpent, uint baseReceived);\\n\\n  /// @dev Emitted whenever base is exchanged for quote\\n  event BaseSold(uint amountBase, uint quoteReceived);\\n\\n  /// @dev Emitted whenever premium is sent to a trader closing their position\\n  event PremiumTransferred(address indexed recipient, uint recipientPortion, uint optionMarketPortion);\\n\\n  /// @dev Emitted whenever quote is sent to the PoolHedger\\n  event QuoteTransferredToPoolHedger(uint amountQuote);\\n\\n  /// @dev Emitted whenever the insolvent settlement amount is updated (settlement and excess)\\n  event InsolventSettlementAmountUpdated(uint amountQuoteAdded, uint totalInsolventSettlementAmount);\\n\\n  /// @dev Emitted whenever a user deposits and enters the queue.\\n  event DepositQueued(\\n    address indexed depositor,\\n    address indexed beneficiary,\\n    uint indexed depositQueueId,\\n    uint amountDeposited,\\n    uint totalQueuedDeposits,\\n    uint timestamp\\n  );\\n\\n  /// @dev Emitted whenever a deposit gets processed. Note, can be processed without being queued.\\n  ///  QueueId of 0 indicates it was not queued.\\n  event DepositProcessed(\\n    address indexed caller,\\n    address indexed beneficiary,\\n    uint indexed depositQueueId,\\n    uint amountDeposited,\\n    uint tokenPrice,\\n    uint tokensReceived,\\n    uint timestamp\\n  );\\n\\n  /// @dev Emitted whenever a deposit gets processed. Note, can be processed without being queued.\\n  ///  QueueId of 0 indicates it was not queued.\\n  event WithdrawProcessed(\\n    address indexed caller,\\n    address indexed beneficiary,\\n    uint indexed withdrawalQueueId,\\n    uint amountWithdrawn,\\n    uint tokenPrice,\\n    uint quoteReceived,\\n    uint totalQueuedWithdrawals,\\n    uint timestamp\\n  );\\n  event WithdrawPartiallyProcessed(\\n    address indexed caller,\\n    address indexed beneficiary,\\n    uint indexed withdrawalQueueId,\\n    uint amountWithdrawn,\\n    uint tokenPrice,\\n    uint quoteReceived,\\n    uint totalQueuedWithdrawals,\\n    uint timestamp\\n  );\\n  event WithdrawQueued(\\n    address indexed withdrawer,\\n    address indexed beneficiary,\\n    uint indexed withdrawalQueueId,\\n    uint amountWithdrawn,\\n    uint totalQueuedWithdrawals,\\n    uint timestamp\\n  );\\n\\n  /// @dev Emitted whenever the CB timestamp is updated\\n  event CircuitBreakerUpdated(\\n    uint newTimestamp,\\n    bool ivVarianceThresholdCrossed,\\n    bool skewVarianceThresholdCrossed,\\n    bool liquidityThresholdCrossed\\n  );\\n\\n  /// @dev Emitted whenever the CB timestamp is updated from a board settlement\\n  event BoardSettlementCircuitBreakerUpdated(uint newTimestamp);\\n\\n  /// @dev Emitted whenever a queue item is checked for the ability to be processed\\n  event CheckingCanProcess(uint entryId, bool boardNotStale, bool validEntry, bool guardianBypass, bool delaysExpired);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  // Admin\\n  error InvalidLiquidityPoolParameters(address thrower, LiquidityPoolParameters lpParams);\\n\\n  // Deposits and withdrawals\\n  error InvalidBeneficiaryAddress(address thrower, address beneficiary);\\n  error MinimumDepositNotMet(address thrower, uint amountQuote, uint minDeposit);\\n  error MinimumWithdrawNotMet(address thrower, uint amountLiquidityToken, uint minWithdraw);\\n\\n  // Liquidity and accounting\\n  error LockingMoreQuoteThanIsFree(address thrower, uint quoteToLock, uint freeLiquidity, Collateral lockedCollateral);\\n  error SendPremiumNotEnoughCollateral(address thrower, uint premium, uint reservedFee, uint freeLiquidity);\\n  error NotEnoughFreeToReclaimInsolvency(address thrower, uint amountQuote, Liquidity liquidity);\\n  error OptionValueDebtExceedsTotalAssets(address thrower, int totalAssetValue, int optionValueDebt);\\n  error InsufficientFreeLiquidityForBaseExchange(\\n    address thrower,\\n    uint pendingBase,\\n    uint estimatedExchangeCost,\\n    uint freeLiquidity\\n  );\\n\\n  // Access\\n  error OnlyPoolHedger(address thrower, address caller, address poolHedger);\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n  error OnlyShortCollateral(address thrower, address caller, address poolHedger);\\n\\n  // Token transfers\\n  error QuoteTransferFailed(address thrower, address from, address to, uint amount);\\n  error BaseTransferFailed(address thrower, address from, address to, uint amount);\\n}\\n\",\"keccak256\":\"0xf00a7d2d96375adddb2190be530632cdea9ac9c5795efc6a85667547e7f7dd2b\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ILyraRegistry.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/IERC20.sol\\\";\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/periphery/LyraRegistry.sol\\\";\\n/// @dev inputs/returns that contain Lyra contracts replaced with addresses (as opposed to LyraRegistry.sol)\\n///      so that interacting contracts are not required to import Lyra contracts\\ninterface ILyraRegistry {\\n  struct OptionMarketAddresses {\\n    address liquidityPool;\\n    address liquidityToken;\\n    address greekCache;\\n    address optionMarket;\\n    address optionMarketPricer;\\n    address optionToken;\\n    address poolHedger;\\n    address shortCollateral;\\n    address gwavOracle;\\n    IERC20 quoteAsset;\\n    IERC20 baseAsset;\\n  }\\n\\n  function optionMarkets() external view returns (address[] memory);\\n\\n  function marketAddress(address market) external view returns (OptionMarketAddresses memory);\\n\\n  function globalAddresses(bytes32 name) external view returns (address);\\n\\n  function getMarketAddresses(address optionMarket) external view returns (OptionMarketAddresses memory);\\n\\n  function getGlobalAddress(bytes32 contractName) external view returns (address globalContract);\\n\\n  event GlobalAddressUpdated(bytes32 indexed name, address addr);\\n\\n  event MarketUpdated(address indexed optionMarket, OptionMarketAddresses market);\\n\\n  event MarketRemoved(address indexed market);\\n\\n  error RemovingInvalidMarket(address thrower, address market);\\n\\n  error NonExistentMarket(address optionMarket);\\n\\n  error NonExistentGlobalContract(bytes32 contractName);\\n}\\n\",\"keccak256\":\"0xbbf5a80a5c8bd044516da03b67a155022199b857704d83bbbc3eac6e90c13312\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IOptionGreekCache.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"./IOptionMarket.sol\\\";\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/interfaces/IOptionGreekCache.sol\\\";\\ninterface IOptionGreekCache {\\n  struct GreekCacheParameters {\\n    // Cap the number of strikes per board to avoid hitting gasLimit constraints\\n    uint maxStrikesPerBoard;\\n    // How much spot price can move since last update before deposits/withdrawals are blocked\\n    uint acceptableSpotPricePercentMove;\\n    // How much time has passed since last update before deposits/withdrawals are blocked\\n    uint staleUpdateDuration;\\n    // Length of the GWAV for the baseline volatility used to fire the vol circuit breaker\\n    uint varianceIvGWAVPeriod;\\n    // Length of the GWAV for the skew ratios used to fire the vol circuit breaker\\n    uint varianceSkewGWAVPeriod;\\n    // Length of the GWAV for the baseline used to determine the NAV of the pool\\n    uint optionValueIvGWAVPeriod;\\n    // Length of the GWAV for the skews used to determine the NAV of the pool\\n    uint optionValueSkewGWAVPeriod;\\n    // Minimum skew that will be fed into the GWAV calculation\\n    // Prevents near 0 values being used to heavily manipulate the GWAV\\n    uint gwavSkewFloor;\\n    // Maximum skew that will be fed into the GWAV calculation\\n    uint gwavSkewCap;\\n    // Interest/risk free rate\\n    int rateAndCarry;\\n  }\\n\\n  struct ForceCloseParameters {\\n    // Length of the GWAV for the baseline vol used in ForceClose() and liquidations\\n    uint ivGWAVPeriod;\\n    // Length of the GWAV for the skew ratio used in ForceClose() and liquidations\\n    uint skewGWAVPeriod;\\n    // When a user buys back an option using ForceClose() we increase the GWAV vol to penalise the trader\\n    uint shortVolShock;\\n    // Increase the penalty when within the trading cutoff\\n    uint shortPostCutoffVolShock;\\n    // When a user sells back an option to the AMM using ForceClose(), we decrease the GWAV to penalise the seller\\n    uint longVolShock;\\n    // Increase the penalty when within the trading cutoff\\n    uint longPostCutoffVolShock;\\n    // Same justification as shortPostCutoffVolShock\\n    uint liquidateVolShock;\\n    // Increase the penalty when within the trading cutoff\\n    uint liquidatePostCutoffVolShock;\\n    // Minimum price the AMM will sell back an option at for force closes (as a % of current spot)\\n    uint shortSpotMin;\\n    // Minimum price the AMM will sell back an option at for liquidations (as a % of current spot)\\n    uint liquidateSpotMin;\\n  }\\n\\n  struct MinCollateralParameters {\\n    // Minimum collateral that must be posted for a short to be opened (denominated in quote)\\n    uint minStaticQuoteCollateral;\\n    // Minimum collateral that must be posted for a short to be opened (denominated in base)\\n    uint minStaticBaseCollateral;\\n    /* Shock Vol:\\n     * Vol used to compute the minimum collateral requirements for short positions.\\n     * This value is derived from the following chart, created by using the 4 values listed below.\\n     *\\n     *     vol\\n     *      |\\n     * volA |____\\n     *      |    \\\\\\n     * volB |     \\\\___\\n     *      |___________ time to expiry\\n     *         A   B\\n     */\\n    uint shockVolA;\\n    uint shockVolPointA;\\n    uint shockVolB;\\n    uint shockVolPointB;\\n    // Static percentage shock to the current spot price for calls\\n    uint callSpotPriceShock;\\n    // Static percentage shock to the current spot price for puts\\n    uint putSpotPriceShock;\\n  }\\n\\n  ///////////////////\\n  // Cache storage //\\n  ///////////////////\\n  struct GlobalCache {\\n    uint minUpdatedAt;\\n    uint minUpdatedAtPrice;\\n    uint maxUpdatedAtPrice;\\n    uint maxSkewVariance;\\n    uint maxIvVariance;\\n    NetGreeks netGreeks;\\n  }\\n\\n  struct OptionBoardCache {\\n    uint id;\\n    uint[] strikes;\\n    uint expiry;\\n    uint iv;\\n    NetGreeks netGreeks;\\n    uint updatedAt;\\n    uint updatedAtPrice;\\n    uint maxSkewVariance;\\n    uint ivVariance;\\n  }\\n\\n  struct StrikeCache {\\n    uint id;\\n    uint boardId;\\n    uint strikePrice;\\n    uint skew;\\n    StrikeGreeks greeks;\\n    int callExposure; // long - short\\n    int putExposure; // long - short\\n    uint skewVariance; // (GWAVSkew - skew)\\n  }\\n\\n  // These are based on GWAVed iv\\n  struct StrikeGreeks {\\n    int callDelta;\\n    int putDelta;\\n    uint stdVega;\\n    uint callPrice;\\n    uint putPrice;\\n  }\\n\\n  // These are based on GWAVed iv\\n  struct NetGreeks {\\n    int netDelta;\\n    int netStdVega;\\n    int netOptionValue;\\n  }\\n\\n  ///////////////\\n  // In-memory //\\n  ///////////////\\n  struct TradePricing {\\n    uint optionPrice;\\n    int preTradeAmmNetStdVega;\\n    int postTradeAmmNetStdVega;\\n    int callDelta;\\n    uint volTraded;\\n    uint ivVariance;\\n    uint vega;\\n  }\\n\\n  struct BoardGreeksView {\\n    NetGreeks boardGreeks;\\n    uint ivGWAV;\\n    StrikeGreeks[] strikeGreeks;\\n    uint[] skewGWAVs;\\n  }\\n\\n  function getPriceForForceClose(\\n    IOptionMarket.TradeParameters memory trade,\\n    IOptionMarket.Strike memory strike,\\n    uint expiry,\\n    uint newVol,\\n    bool isPostCutoff\\n  ) external view returns (uint optionPrice, uint forceCloseVol);\\n\\n  function getMinCollateral(\\n    IOptionMarket.OptionType optionType,\\n    uint strikePrice,\\n    uint expiry,\\n    uint spotPrice,\\n    uint amount\\n  ) external view returns (uint minCollateral);\\n\\n  function getShockVol(uint timeToMaturity) external view returns (uint);\\n\\n  function updateBoardCachedGreeks(uint boardId) external;\\n\\n  function isGlobalCacheStale(uint spotPrice) external view returns (bool);\\n\\n  function isBoardCacheStale(uint boardId) external view returns (bool);\\n\\n  /////////////////////////////\\n  // External View functions //\\n  /////////////////////////////\\n\\n  /// @notice Get the current cached global netDelta exposure.\\n  function getGlobalNetDelta() external view returns (int);\\n\\n  /// @notice Get the current global net option value\\n  function getGlobalOptionValue() external view returns (int);\\n\\n  /// @notice Returns the BoardGreeksView struct given a specific boardId\\n  function getBoardGreeksView(uint boardId) external view returns (BoardGreeksView memory);\\n\\n  /// @notice Get StrikeCache given a specific strikeId\\n  function getStrikeCache(uint strikeId) external view returns (StrikeCache memory);\\n\\n  /// @notice Get OptionBoardCache given a specific boardId\\n  function getOptionBoardCache(uint boardId) external view returns (OptionBoardCache memory);\\n\\n  /// @notice Get the global cache\\n  function getGlobalCache() external view returns (GlobalCache memory);\\n\\n  /// @notice Returns ivGWAV for a given boardId and GWAV time interval\\n  function getIvGWAV(uint boardId, uint secondsAgo) external view returns (uint ivGWAV);\\n\\n  /// @notice Returns skewGWAV for a given strikeId and GWAV time interval\\n  function getSkewGWAV(uint strikeId, uint secondsAgo) external view returns (uint skewGWAV);\\n\\n  /// @notice Get the GreekCacheParameters\\n  function getGreekCacheParams() external view returns (GreekCacheParameters memory);\\n\\n  /// @notice Get the ForceCloseParamters\\n  function getForceCloseParams() external view returns (ForceCloseParameters memory);\\n\\n  /// @notice Get the MinCollateralParamters\\n  function getMinCollatParams() external view returns (MinCollateralParameters memory);\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  event GreekCacheParametersSet(GreekCacheParameters params);\\n  event ForceCloseParametersSet(ForceCloseParameters params);\\n  event MinCollateralParametersSet(MinCollateralParameters params);\\n\\n  event StrikeCacheUpdated(StrikeCache strikeCache);\\n  event BoardCacheUpdated(OptionBoardCache boardCache);\\n  event GlobalCacheUpdated(GlobalCache globalCache);\\n\\n  event BoardCacheRemoved(uint boardId);\\n  event StrikeCacheRemoved(uint strikeId);\\n  event BoardIvUpdated(uint boardId, uint newIv, uint globalMaxIvVariance);\\n  event StrikeSkewUpdated(uint strikeId, uint newSkew, uint globalMaxSkewVariance);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Admin\\n  error InvalidGreekCacheParameters(address thrower, GreekCacheParameters greekCacheParams);\\n  error InvalidForceCloseParameters(address thrower, ForceCloseParameters forceCloseParams);\\n  error InvalidMinCollatParams(address thrower, MinCollateralParameters minCollatParams);\\n\\n  // Board related\\n  error BoardStrikeLimitExceeded(address thrower, uint boardId, uint newStrikesLength, uint maxStrikesPerBoard);\\n  error InvalidBoardId(address thrower, uint boardId);\\n  error CannotUpdateExpiredBoard(address thrower, uint boardId, uint expiry, uint currentTimestamp);\\n\\n  // Access\\n  error OnlyIOptionMarket(address thrower, address caller, address optionMarket);\\n  error OnlyIOptionMarketPricer(address thrower, address caller, address optionMarketPricer);\\n}\\n\",\"keccak256\":\"0x95cca08290203ad24f382041e8637c71e98d1f60fd1ddffed55c65122cc09252\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IOptionMarket.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"./ILiquidityPool.sol\\\";\\nimport \\\"./ISynthetixAdapter.sol\\\";\\nimport \\\"./IOptionMarketPricer.sol\\\";\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/OptionMarket.sol\\\";\\ninterface IOptionMarket {\\n  enum TradeDirection {\\n    OPEN,\\n    CLOSE,\\n    LIQUIDATE\\n  }\\n\\n  enum OptionType {\\n    LONG_CALL,\\n    LONG_PUT,\\n    SHORT_CALL_BASE,\\n    SHORT_CALL_QUOTE,\\n    SHORT_PUT_QUOTE\\n  }\\n\\n  /// @notice For returning more specific errors\\n  enum NonZeroValues {\\n    BASE_IV,\\n    SKEW,\\n    STRIKE_PRICE,\\n    ITERATIONS,\\n    STRIKE_ID\\n  }\\n\\n  ///////////////////\\n  // Internal Data //\\n  ///////////////////\\n\\n  struct Strike {\\n    // strike listing identifier\\n    uint id;\\n    // strike price\\n    uint strikePrice;\\n    // volatility component specific to the strike listing (boardIv * skew = vol of strike)\\n    uint skew;\\n    // total user long call exposure\\n    uint longCall;\\n    // total user short call (base collateral) exposure\\n    uint shortCallBase;\\n    // total user short call (quote collateral) exposure\\n    uint shortCallQuote;\\n    // total user long put exposure\\n    uint longPut;\\n    // total user short put (quote collateral) exposure\\n    uint shortPut;\\n    // id of board to which strike belongs\\n    uint boardId;\\n  }\\n\\n  struct OptionBoard {\\n    // board identifier\\n    uint id;\\n    // expiry of all strikes belonging to board\\n    uint expiry;\\n    // volatility component specific to board (boardIv * skew = vol of strike)\\n    uint iv;\\n    // admin settable flag blocking all trading on this board\\n    bool frozen;\\n    // list of all strikes belonging to this board\\n    uint[] strikeIds;\\n  }\\n\\n  ///////////////\\n  // In-memory //\\n  ///////////////\\n\\n  struct OptionMarketParameters {\\n    // max allowable expiry of added boards\\n    uint maxBoardExpiry;\\n    // security module address\\n    address securityModule;\\n    // fee portion reserved for Lyra DAO\\n    uint feePortionReserved;\\n    // expected fee charged to LPs, used for pricing short_call_base settlement\\n    uint staticBaseSettlementFee;\\n  }\\n\\n  struct TradeInputParameters {\\n    // id of strike\\n    uint strikeId;\\n    // OptionToken ERC721 id for position (set to 0 for new positions)\\n    uint positionId;\\n    // number of sub-orders to break order into (reduces slippage)\\n    uint iterations;\\n    // type of option to trade\\n    OptionType optionType;\\n    // number of contracts to trade\\n    uint amount;\\n    // final amount of collateral to leave in OptionToken position\\n    uint setCollateralTo;\\n    // revert trade if totalCost is below this value\\n    uint minTotalCost;\\n    // revert trade if totalCost is above this value\\n    uint maxTotalCost;\\n  }\\n\\n  struct TradeParameters {\\n    bool isBuy;\\n    bool isForceClose;\\n    TradeDirection tradeDirection;\\n    OptionType optionType;\\n    uint amount;\\n    uint expiry;\\n    uint strikePrice;\\n    ILiquidityPool.Liquidity liquidity;\\n    ISynthetixAdapter.ExchangeParams exchangeParams;\\n  }\\n\\n  struct TradeEventData {\\n    uint expiry;\\n    uint strikePrice;\\n    OptionType optionType;\\n    TradeDirection tradeDirection;\\n    uint amount;\\n    uint setCollateralTo;\\n    bool isForceClose;\\n    uint spotPrice;\\n    uint reservedFee;\\n    uint totalCost;\\n  }\\n\\n  struct LiquidationEventData {\\n    address rewardBeneficiary;\\n    address caller;\\n    uint returnCollateral; // quote || base\\n    uint lpPremiums; // quote || base\\n    uint lpFee; // quote || base\\n    uint liquidatorFee; // quote || base\\n    uint smFee; // quote || base\\n    uint insolventAmount; // quote\\n  }\\n\\n  struct Result {\\n    uint positionId;\\n    uint totalCost;\\n    uint totalFee;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n\\n  /// @notice claim all reserved option fees\\n  function smClaim() external;\\n\\n  ///////////\\n  // Views //\\n  ///////////\\n\\n  function getOptionMarketParams() external view returns (OptionMarketParameters memory);\\n\\n  function getLiveBoards() external view returns (uint[] memory _liveBoards);\\n\\n  function getNumLiveBoards() external view returns (uint numLiveBoards);\\n\\n  function getStrikeAndExpiry(uint strikeId) external view returns (uint strikePrice, uint expiry);\\n\\n  function getBoardStrikes(uint boardId) external view returns (uint[] memory strikeIds);\\n\\n  function getStrike(uint strikeId) external view returns (Strike memory);\\n\\n  function getOptionBoard(uint boardId) external view returns (OptionBoard memory);\\n\\n  function getStrikeAndBoard(uint strikeId) external view returns (Strike memory, OptionBoard memory);\\n\\n  function getBoardAndStrikeDetails(uint boardId)\\n    external\\n    view\\n    returns (\\n      OptionBoard memory,\\n      Strike[] memory,\\n      uint[] memory,\\n      uint\\n    );\\n\\n  ////////////////////\\n  // User functions //\\n  ////////////////////\\n\\n  function openPosition(TradeInputParameters memory params) external returns (Result memory result);\\n\\n  function closePosition(TradeInputParameters memory params) external returns (Result memory result);\\n\\n  /**\\n   * @notice Attempts to reduce or fully close position within cost bounds while ignoring delta trading cutoffs.\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function forceClosePosition(TradeInputParameters memory params) external returns (Result memory result);\\n\\n  function addCollateral(uint positionId, uint amountCollateral) external;\\n\\n  function liquidatePosition(uint positionId, address rewardBeneficiary) external;\\n\\n  /////////////////////////////////\\n  // Board Expiry and settlement //\\n  /////////////////////////////////\\n\\n  function settleExpiredBoard(uint boardId) external;\\n\\n  function getSettlementParameters(uint strikeId)\\n    external\\n    view\\n    returns (\\n      uint strikePrice,\\n      uint priceAtExpiry,\\n      uint strikeToBaseReturned\\n    );\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /**\\n   * @dev Emitted when a Board is created.\\n   */\\n  event BoardCreated(uint indexed boardId, uint expiry, uint baseIv, bool frozen);\\n\\n  /**\\n   * @dev Emitted when a Board frozen is updated.\\n   */\\n  event BoardFrozen(uint indexed boardId, bool frozen);\\n\\n  /**\\n   * @dev Emitted when a Board new baseIv is set.\\n   */\\n  event BoardBaseIvSet(uint indexed boardId, uint baseIv);\\n\\n  /**\\n   * @dev Emitted when a Strike new skew is set.\\n   */\\n  event StrikeSkewSet(uint indexed strikeId, uint skew);\\n\\n  /**\\n   * @dev Emitted when a Strike is added to a board\\n   */\\n  event StrikeAdded(uint indexed boardId, uint indexed strikeId, uint strikePrice, uint skew);\\n\\n  /**\\n   * @dev Emitted when parameters for the option market are adjusted\\n   */\\n  event OptionMarketParamsSet(OptionMarketParameters optionMarketParams);\\n\\n  /**\\n   * @dev Emitted whenever the security module claims their portion of fees\\n   */\\n  event SMClaimed(address securityModule, uint quoteAmount, uint baseAmount);\\n\\n  /**\\n   * @dev Emitted when a Position is opened, closed or liquidated.\\n   */\\n  event Trade(\\n    address indexed trader,\\n    uint indexed strikeId,\\n    uint indexed positionId,\\n    TradeEventData trade,\\n    IOptionMarketPricer.TradeResult[] tradeResults,\\n    LiquidationEventData liquidation,\\n    uint timestamp\\n  );\\n\\n  /**\\n   * @dev Emitted when a Board is liquidated.\\n   */\\n  event BoardSettled(\\n    uint indexed boardId,\\n    uint spotPriceAtExpiry,\\n    uint totalUserLongProfitQuote,\\n    uint totalBoardLongCallCollateral,\\n    uint totalBoardLongPutCollateral,\\n    uint totalAMMShortCallProfitBase,\\n    uint totalAMMShortCallProfitQuote,\\n    uint totalAMMShortPutProfitQuote\\n  );\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // General purpose\\n  error ExpectedNonZeroValue(address thrower, NonZeroValues valueType);\\n\\n  // Admin\\n  error InvalidOptionMarketParams(address thrower, OptionMarketParameters optionMarketParams);\\n\\n  // Board related\\n  error InvalidBoardId(address thrower, uint boardId);\\n  error InvalidExpiryTimestamp(address thrower, uint currentTime, uint expiry, uint maxBoardExpiry);\\n  error BoardNotFrozen(address thrower, uint boardId);\\n  error BoardAlreadySettled(address thrower, uint boardId);\\n  error BoardNotExpired(address thrower, uint boardId);\\n\\n  // Strike related\\n  error InvalidStrikeId(address thrower, uint strikeId);\\n  error StrikeSkewLengthMismatch(address thrower, uint strikesLength, uint skewsLength);\\n\\n  // Trade\\n  error TotalCostOutsideOfSpecifiedBounds(address thrower, uint totalCost, uint minCost, uint maxCost);\\n  error BoardIsFrozen(address thrower, uint boardId);\\n  error BoardExpired(address thrower, uint boardId, uint boardExpiry, uint currentTime);\\n  error TradeIterationsHasRemainder(\\n    address thrower,\\n    uint iterations,\\n    uint expectedAmount,\\n    uint tradeAmount,\\n    uint totalAmount\\n  );\\n\\n  // Access\\n  error OnlySecurityModule(address thrower, address caller, address securityModule);\\n\\n  // Token transfers\\n  error BaseTransferFailed(address thrower, address from, address to, uint amount);\\n  error QuoteTransferFailed(address thrower, address from, address to, uint amount);\\n}\\n\",\"keccak256\":\"0x96fbcb6ea69a0dae273aae3aa002a292639da805861c91e18b808a308900664e\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IOptionMarketPricer.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"./IOptionMarket.sol\\\";\\nimport \\\"./IOptionGreekCache.sol\\\";\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/OptionMarketPricer.sol\\\";\\ninterface IOptionMarketPricer {\\n  struct PricingParameters {\\n    // Percentage of option price that is charged as a fee\\n    uint optionPriceFeeCoefficient;\\n    // Refer to: getTimeWeightedFee()\\n    uint optionPriceFee1xPoint;\\n    uint optionPriceFee2xPoint;\\n    // Percentage of spot price that is charged as a fee per option\\n    uint spotPriceFeeCoefficient;\\n    // Refer to: getTimeWeightedFee()\\n    uint spotPriceFee1xPoint;\\n    uint spotPriceFee2xPoint;\\n    // Refer to: getVegaUtilFee()\\n    uint vegaFeeCoefficient;\\n    // The amount of options traded to move baseIv for the board up or down 1 point (depending on trade direction)\\n    uint standardSize;\\n    // The relative move of skew for a given strike based on standard sizes traded\\n    uint skewAdjustmentFactor;\\n  }\\n\\n  struct TradeLimitParameters {\\n    // Delta cutoff past which no options can be traded (optionD > minD && optionD < 1 - minD) - using call delta\\n    int minDelta;\\n    // Delta cutoff at which ForceClose can be called (optionD < minD || optionD > 1 - minD) - using call delta\\n    int minForceCloseDelta;\\n    // Time when trading closes. Only ForceClose can be called after this\\n    uint tradingCutoff;\\n    // Lowest baseIv for a board that can be traded for regular option opens/closes\\n    uint minBaseIV;\\n    // Maximal baseIv for a board that can be traded for regular option opens/closes\\n    uint maxBaseIV;\\n    // Lowest skew for a strike that can be traded for regular option opens/closes\\n    uint minSkew;\\n    // Maximal skew for a strike that can be traded for regular option opens/closes\\n    uint maxSkew;\\n    // Minimal vol traded for regular option opens/closes (baseIv * skew)\\n    uint minVol;\\n    // Maximal vol traded for regular option opens/closes (baseIv * skew)\\n    uint maxVol;\\n    // Absolute lowest skew that ForceClose can go to\\n    uint absMinSkew;\\n    // Absolute highest skew that ForceClose can go to\\n    uint absMaxSkew;\\n    // Cap the skew the abs max/min skews - only relevant to liquidations\\n    bool capSkewsToAbs;\\n  }\\n\\n  struct VarianceFeeParameters {\\n    uint defaultVarianceFeeCoefficient;\\n    uint forceCloseVarianceFeeCoefficient;\\n    // coefficient that allows the skew component of the fee to be scaled up\\n    uint skewAdjustmentCoefficient;\\n    // measures the difference of the skew to a reference skew\\n    uint referenceSkew;\\n    // constant to ensure small vega terms have a fee\\n    uint minimumStaticSkewAdjustment;\\n    // coefficient that allows the vega component of the fee to be scaled up\\n    uint vegaCoefficient;\\n    // constant to ensure small vega terms have a fee\\n    uint minimumStaticVega;\\n    // coefficient that allows the ivVariance component of the fee to be scaled up\\n    uint ivVarianceCoefficient;\\n    // constant to ensure small variance terms have a fee\\n    uint minimumStaticIvVariance;\\n  }\\n\\n  ///////////////\\n  // In-memory //\\n  ///////////////\\n  struct TradeResult {\\n    uint amount;\\n    uint premium;\\n    uint optionPriceFee;\\n    uint spotPriceFee;\\n    VegaUtilFeeComponents vegaUtilFee;\\n    VarianceFeeComponents varianceFee;\\n    uint totalFee;\\n    uint totalCost;\\n    uint volTraded;\\n    uint newBaseIv;\\n    uint newSkew;\\n  }\\n\\n  struct VegaUtilFeeComponents {\\n    int preTradeAmmNetStdVega;\\n    int postTradeAmmNetStdVega;\\n    uint vegaUtil;\\n    uint volTraded;\\n    uint NAV;\\n    uint vegaUtilFee;\\n  }\\n\\n  struct VarianceFeeComponents {\\n    uint varianceFeeCoefficient;\\n    uint vega;\\n    uint vegaCoefficient;\\n    uint skew;\\n    uint skewCoefficient;\\n    uint ivVariance;\\n    uint ivVarianceCoefficient;\\n    uint varianceFee;\\n  }\\n\\n  struct VolComponents {\\n    uint vol;\\n    uint baseIv;\\n    uint skew;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n\\n  function pricingParams() external view returns (PricingParameters memory);\\n\\n  function tradeLimitParams() external view returns (TradeLimitParameters memory);\\n\\n  function varianceFeeParams() external view returns (VarianceFeeParameters memory);\\n\\n  function ivImpactForTrade(\\n    IOptionMarket.TradeParameters memory trade,\\n    uint boardBaseIv,\\n    uint strikeSkew\\n  ) external view returns (uint newBaseIv, uint newSkew);\\n\\n  function getTradeResult(\\n    IOptionMarket.TradeParameters memory trade,\\n    IOptionGreekCache.TradePricing memory pricing,\\n    uint newBaseIv,\\n    uint newSkew\\n  ) external view returns (TradeResult memory tradeResult);\\n\\n  function getTimeWeightedFee(\\n    uint expiry,\\n    uint pointA,\\n    uint pointB,\\n    uint coefficient\\n  ) external view returns (uint timeWeightedFee);\\n\\n  function getVegaUtilFee(IOptionMarket.TradeParameters memory trade, IOptionGreekCache.TradePricing memory pricing)\\n    external\\n    view\\n    returns (VegaUtilFeeComponents memory vegaUtilFeeComponents);\\n\\n  function getVarianceFee(\\n    IOptionMarket.TradeParameters memory trade,\\n    IOptionGreekCache.TradePricing memory pricing,\\n    uint skew\\n  ) external view returns (VarianceFeeComponents memory varianceFeeComponents);\\n\\n  /////////////////////////////\\n  // External View functions //\\n  /////////////////////////////\\n\\n  function getPricingParams() external view returns (PricingParameters memory pricingParameters);\\n\\n  function getTradeLimitParams() external view returns (TradeLimitParameters memory tradeLimitParameters);\\n\\n  function getVarianceFeeParams() external view returns (VarianceFeeParameters memory varianceFeeParameters);\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  event PricingParametersSet(PricingParameters pricingParams);\\n  event TradeLimitParametersSet(TradeLimitParameters tradeLimitParams);\\n  event VarianceFeeParametersSet(VarianceFeeParameters varianceFeeParams);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Admin\\n  error InvalidTradeLimitParameters(address thrower, TradeLimitParameters tradeLimitParams);\\n  error InvalidPricingParameters(address thrower, PricingParameters pricingParams);\\n\\n  // Trade limitations\\n  error TradingCutoffReached(address thrower, uint tradingCutoff, uint boardExpiry, uint currentTime);\\n  error ForceCloseSkewOutOfRange(address thrower, bool isBuy, uint newSkew, uint minSkew, uint maxSkew);\\n  error VolSkewOrBaseIvOutsideOfTradingBounds(\\n    address thrower,\\n    bool isBuy,\\n    VolComponents currentVol,\\n    VolComponents newVol,\\n    VolComponents tradeBounds\\n  );\\n  error TradeDeltaOutOfRange(address thrower, int strikeCallDelta, int minDelta, int maxDelta);\\n  error ForceCloseDeltaOutOfRange(address thrower, int strikeCallDelta, int minDelta, int maxDelta);\\n\\n  // Access\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n}\\n\",\"keccak256\":\"0x46099a691d4df6ba1b33bd81ee7b353ec1d4b6a7694b5f6c114de4d98df3b303\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IOptionToken.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Interfaces\\nimport \\\"./IOptionMarket.sol\\\";\\nimport \\\"./ISynthetixAdapter.sol\\\";\\nimport \\\"./IOptionGreekCache.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC721/IERC721.sol\\\";\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/OptionToken.sol\\\";\\ninterface IOptionToken is IERC721 {\\n  enum PositionState {\\n    EMPTY,\\n    ACTIVE,\\n    CLOSED,\\n    LIQUIDATED,\\n    SETTLED,\\n    MERGED\\n  }\\n\\n  enum PositionUpdatedType {\\n    OPENED,\\n    ADJUSTED,\\n    CLOSED,\\n    SPLIT_FROM,\\n    SPLIT_INTO,\\n    MERGED,\\n    MERGED_INTO,\\n    SETTLED,\\n    LIQUIDATED,\\n    TRANSFER\\n  }\\n\\n  struct OptionPosition {\\n    uint positionId;\\n    uint strikeId;\\n    IOptionMarket.OptionType optionType;\\n    uint amount;\\n    uint collateral;\\n    PositionState state;\\n  }\\n\\n  struct PartialCollateralParameters {\\n    // Percent of collateral used for penalty (amm + sm + liquidator fees)\\n    uint penaltyRatio;\\n    // Percent of penalty used for amm fees\\n    uint liquidatorFeeRatio;\\n    // Percent of penalty used for SM fees\\n    uint smFeeRatio;\\n    // Minimal value of quote that is used to charge a fee\\n    uint minLiquidationFee;\\n  }\\n\\n  struct PositionWithOwner {\\n    uint positionId;\\n    uint strikeId;\\n    IOptionMarket.OptionType optionType;\\n    uint amount;\\n    uint collateral;\\n    PositionState state;\\n    address owner;\\n  }\\n\\n  struct LiquidationFees {\\n    uint returnCollateral; // quote || base\\n    uint lpPremiums; // quote || base\\n    uint lpFee; // quote || base\\n    uint liquidatorFee; // quote || base\\n    uint smFee; // quote || base\\n    uint insolventAmount; // quote\\n  }\\n\\n  function positions(uint positionId) external view returns (OptionPosition memory);\\n\\n  function nextId() external view returns (uint);\\n\\n  function partialCollatParams() external view returns (PartialCollateralParameters memory);\\n\\n  function baseURI() external view returns (string memory);\\n\\n  function canLiquidate(\\n    OptionPosition memory position,\\n    uint expiry,\\n    uint strikePrice,\\n    uint spotPrice\\n  ) external view returns (bool);\\n\\n  function getLiquidationFees(\\n    uint gwavPremium, // quote || base\\n    uint userPositionCollateral, // quote || base\\n    uint convertedMinLiquidationFee, // quote || base\\n    uint insolvencyMultiplier // 1 for quote || spotPrice for base\\n  ) external view returns (LiquidationFees memory liquidationFees);\\n\\n  ///////////////\\n  // Transfers //\\n  ///////////////\\n\\n  function split(\\n    uint positionId,\\n    uint newAmount,\\n    uint newCollateral,\\n    address recipient\\n  ) external returns (uint newPositionId);\\n\\n  function merge(uint[] memory positionIds) external;\\n\\n  //////////\\n  // View //\\n  //////////\\n\\n  /// @dev Returns the PositionState of a given positionId\\n  function getPositionState(uint positionId) external view returns (PositionState);\\n\\n  /// @dev Returns an OptionPosition struct of a given positionId\\n  function getOptionPosition(uint positionId) external view returns (OptionPosition memory);\\n\\n  /// @dev Returns an array of OptionPosition structs given an array of positionIds\\n  function getOptionPositions(uint[] memory positionIds) external view returns (OptionPosition[] memory);\\n\\n  /// @dev Returns a PositionWithOwner struct of a given positionId (same as OptionPosition but with owner)\\n  function getPositionWithOwner(uint positionId) external view returns (PositionWithOwner memory);\\n\\n  /// @dev Returns an array of PositionWithOwner structs given an array of positionIds\\n  function getPositionsWithOwner(uint[] memory positionIds) external view returns (PositionWithOwner[] memory);\\n\\n  /// @notice Returns an array of OptionPosition structs owned by a given address\\n  /// @dev Meant to be used offchain as it can run out of gas\\n  function getOwnerPositions(address target) external view returns (OptionPosition[] memory);\\n\\n  /// @dev returns PartialCollateralParameters struct\\n  function getPartialCollatParams() external view returns (PartialCollateralParameters memory);\\n\\n  ////////////\\n  // Events //\\n  ///////////\\n\\n  /**\\n   * @dev Emitted when the URI is modified\\n   */\\n  event URISet(string URI);\\n\\n  /**\\n   * @dev Emitted when partial collateral parameters are modified\\n   */\\n  event PartialCollateralParamsSet(PartialCollateralParameters partialCollateralParams);\\n\\n  /**\\n   * @dev Emitted when a position is minted, adjusted, burned, merged or split.\\n   */\\n  event PositionUpdated(\\n    uint indexed positionId,\\n    address indexed owner,\\n    PositionUpdatedType indexed updatedType,\\n    OptionPosition position,\\n    uint timestamp\\n  );\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  // Admin\\n  error InvalidPartialCollateralParameters(address thrower, PartialCollateralParameters partialCollatParams);\\n\\n  // Adjusting\\n  error AdjustmentResultsInMinimumCollateralNotBeingMet(address thrower, OptionPosition position, uint spotPrice);\\n  error CannotClosePositionZero(address thrower);\\n  error CannotOpenZeroAmount(address thrower);\\n  error CannotAdjustInvalidPosition(\\n    address thrower,\\n    uint positionId,\\n    bool invalidPositionId,\\n    bool positionInactive,\\n    bool strikeMismatch,\\n    bool optionTypeMismatch\\n  );\\n  error OnlyOwnerCanAdjustPosition(address thrower, uint positionId, address trader, address owner);\\n  error FullyClosingWithNonZeroSetCollateral(address thrower, uint positionId, uint setCollateralTo);\\n  error AddingCollateralToInvalidPosition(\\n    address thrower,\\n    uint positionId,\\n    bool invalidPositionId,\\n    bool positionInactive,\\n    bool isShort\\n  );\\n\\n  // Liquidation\\n  error PositionNotLiquidatable(address thrower, OptionPosition position, uint spotPrice);\\n\\n  // Splitting\\n  error SplittingUnapprovedPosition(address thrower, address caller, uint positionId);\\n  error InvalidSplitAmount(address thrower, uint originalPositionAmount, uint splitAmount);\\n  error ResultingOriginalPositionLiquidatable(address thrower, OptionPosition position, uint spotPrice);\\n  error ResultingNewPositionLiquidatable(address thrower, OptionPosition position, uint spotPrice);\\n\\n  // Merging\\n  error MustMergeTwoOrMorePositions(address thrower);\\n  error MergingUnapprovedPosition(address thrower, address caller, uint positionId);\\n  error PositionMismatchWhenMerging(\\n    address thrower,\\n    OptionPosition firstPosition,\\n    OptionPosition nextPosition,\\n    bool ownerMismatch,\\n    bool strikeMismatch,\\n    bool optionTypeMismatch,\\n    bool duplicatePositionId\\n  );\\n\\n  // Access\\n  error StrikeIsSettled(address thrower, uint strikeId);\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n  error OnlyShortCollateral(address thrower, address caller, address shortCollateral);\\n}\\n\",\"keccak256\":\"0xe7ace07236ce9566d7a51428502ea8fac5a8b0a97acf0cf18306c574601d783c\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/IShortCollateral.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\n\\npragma solidity 0.8.9;\\n\\n// Interfaces\\nimport \\\"./IOptionMarket.sol\\\";\\nimport \\\"./IOptionToken.sol\\\";\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/ShortCollateral.sol\\\";\\n\\ninterface IShortCollateral {\\n  // The amount the SC underpaid the LP due to insolvency.\\n  // The SC will take this much less from the LP when settling insolvent positions.\\n  function LPBaseExcess() external view returns (uint);\\n\\n  function LPQuoteExcess() external view returns (uint);\\n\\n  /////////////////////////\\n  // Position Settlement //\\n  /////////////////////////\\n\\n  function settleOptions(uint[] memory positionIds) external;\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /// @dev Emitted when a board is settled\\n  event BoardSettlementCollateralSent(\\n    uint amountBaseSent,\\n    uint amountQuoteSent,\\n    uint lpBaseInsolvency,\\n    uint lpQuoteInsolvency,\\n    uint LPBaseExcess,\\n    uint LPQuoteExcess\\n  );\\n\\n  /**\\n   * @dev Emitted when an Option is settled.\\n   */\\n  event PositionSettled(\\n    uint indexed positionId,\\n    address indexed settler,\\n    address indexed optionOwner,\\n    uint strikePrice,\\n    uint priceAtExpiry,\\n    IOptionMarket.OptionType optionType,\\n    uint amount,\\n    uint settlementAmount,\\n    uint insolventAmount\\n  );\\n\\n  /**\\n   * @dev Emitted when quote is sent to either a user or the LiquidityPool\\n   */\\n  event QuoteSent(address indexed receiver, uint amount);\\n  /**\\n   * @dev Emitted when base is sent to either a user or the LiquidityPool\\n   */\\n  event BaseSent(address indexed receiver, uint amount);\\n\\n  event BaseExchangedAndQuoteSent(address indexed recipient, uint amountBase, uint quoteReceived);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  // Collateral transfers\\n  error OutOfQuoteCollateralForTransfer(address thrower, uint balance, uint amount);\\n  error OutOfBaseCollateralForTransfer(address thrower, uint balance, uint amount);\\n  error OutOfBaseCollateralForExchangeAndTransfer(address thrower, uint balance, uint amount);\\n\\n  // Token transfers\\n  error BaseTransferFailed(address thrower, address from, address to, uint amount);\\n  error QuoteTransferFailed(address thrower, address from, address to, uint amount);\\n\\n  // Access\\n  error BoardMustBeSettled(address thrower, IOptionToken.PositionWithOwner position);\\n  error OnlyOptionMarket(address thrower, address caller, address optionMarket);\\n}\\n\",\"keccak256\":\"0xeaeb5c36763cdbb03d899c8215e41aeee1c692e0b35cc60187d33b78435ba202\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ISynthetix.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity ^0.8.9;\\n\\ninterface ISynthetix {\\n  function exchange(\\n    bytes32 sourceCurrencyKey,\\n    uint sourceAmount,\\n    bytes32 destinationCurrencyKey\\n  ) external returns (uint amountReceived);\\n\\n  function exchangeOnBehalfWithTracking(\\n    address exchangeForAddress,\\n    bytes32 sourceCurrencyKey,\\n    uint sourceAmount,\\n    bytes32 destinationCurrencyKey,\\n    address rewardAddress,\\n    bytes32 trackingCode\\n  ) external returns (uint amountReceived);\\n}\\n\",\"keccak256\":\"0x8b115aed5963422a16354518ce83459c83aebf181488ba36fa91d657d4a314cf\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/interfaces/ISynthetixAdapter.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"./IAddressResolver.sol\\\";\\nimport \\\"./ISynthetix.sol\\\";\\nimport \\\"./IExchanger.sol\\\";\\nimport \\\"./IExchangeRates.sol\\\";\\nimport \\\"./IDelegateApprovals.sol\\\";\\n\\n// For full documentation refer to @lyrafinance/protocol/contracts/SynthetixAdapter.sol\\\";\\ninterface ISynthetixAdapter {\\n  struct ExchangeParams {\\n    // snx oracle exchange rate for base\\n    uint spotPrice;\\n    // snx quote asset identifier key\\n    bytes32 quoteKey;\\n    // snx base asset identifier key\\n    bytes32 baseKey;\\n    // snx spot exchange rate from quote to base\\n    uint quoteBaseFeeRate;\\n    // snx spot exchange rate from base to quote\\n    uint baseQuoteFeeRate;\\n  }\\n\\n  /// @dev Pause the whole system. Note; this will not pause settling previously expired options.\\n  function isMarketPaused(address market) external view returns (bool);\\n\\n  function isGlobalPaused() external view returns (bool);\\n\\n  function addressResolver() external view returns (address);\\n\\n  function synthetix() external view returns (address);\\n\\n  function exchanger() external view returns (address);\\n\\n  function exchangeRates() external view returns (address);\\n\\n  function delegateApprovals() external view returns (address);\\n\\n  // Variables related to calculating premium/fees\\n  function quoteKey(address market) external view returns (bytes32);\\n\\n  function baseKey(address market) external view returns (bytes32);\\n\\n  function rewardAddress(address market) external view returns (bytes32);\\n\\n  function trackingCode(address market) external view returns (bytes32);\\n\\n  function updateSynthetixAddresses() external;\\n\\n  /////////////\\n  // Getters //\\n  /////////////\\n\\n  function getSpotPriceForMarket(address _contractAddress) external view returns (uint spotPrice);\\n\\n  function getSpotPrice(bytes32 to) external view returns (uint);\\n\\n  function getExchangeParams(address optionMarket) external view returns (ExchangeParams memory exchangeParams);\\n\\n  function requireNotGlobalPaused(address optionMarket) external view;\\n\\n  /////////////////////////////////////////\\n  // Exchanging QuoteAsset for BaseAsset //\\n  /////////////////////////////////////////\\n\\n  function exchangeFromExactQuote(address optionMarket, uint amountQuote) external returns (uint baseReceived);\\n\\n  function exchangeToExactBase(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountBase\\n  ) external returns (uint quoteSpent, uint baseReceived);\\n\\n  function exchangeToExactBaseWithLimit(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountBase,\\n    uint quoteLimit\\n  ) external returns (uint quoteSpent, uint baseReceived);\\n\\n  function estimateExchangeToExactBase(ExchangeParams memory exchangeParams, uint amountBase)\\n    external\\n    pure\\n    returns (uint quoteNeeded);\\n\\n  /////////////////////////////////////////\\n  // Exchanging BaseAsset for QuoteAsset //\\n  /////////////////////////////////////////\\n\\n  function exchangeFromExactBase(address optionMarket, uint amountBase) external returns (uint quoteReceived);\\n\\n  function exchangeToExactQuote(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountQuote\\n  ) external returns (uint baseSpent, uint quoteReceived);\\n\\n  function exchangeToExactQuoteWithLimit(\\n    ExchangeParams memory exchangeParams,\\n    address optionMarket,\\n    uint amountQuote,\\n    uint baseLimit\\n  ) external returns (uint baseSpent, uint quoteReceived);\\n\\n  function estimateExchangeToExactQuote(ExchangeParams memory exchangeParams, uint amountQuote)\\n    external\\n    pure\\n    returns (uint baseNeeded);\\n\\n  ////////////\\n  // Events //\\n  ////////////\\n\\n  /**\\n   * @dev Emitted when the address resolver is set.\\n   */\\n  event AddressResolverSet(IAddressResolver addressResolver);\\n  /**\\n   * @dev Emitted when synthetix contracts are updated.\\n   */\\n  event SynthetixAddressesUpdated(\\n    ISynthetix synthetix,\\n    IExchanger exchanger,\\n    IExchangeRates exchangeRates,\\n    IDelegateApprovals delegateApprovals\\n  );\\n  /**\\n   * @dev Emitted when values for a given option market are set.\\n   */\\n  event GlobalsSetForContract(\\n    address indexed market,\\n    bytes32 quoteKey,\\n    bytes32 baseKey,\\n    address rewardAddress,\\n    bytes32 trackingCode\\n  );\\n  /**\\n   * @dev Emitted when GlobalPause.\\n   */\\n  event GlobalPausedSet(bool isPaused);\\n  /**\\n   * @dev Emitted when single market paused.\\n   */\\n  event MarketPausedSet(address contractAddress, bool isPaused);\\n  /**\\n   * @dev Emitted when an exchange for base to quote occurs.\\n   * Which base and quote were swapped can be determined by the given marketAddress.\\n   */\\n  event BaseSwappedForQuote(\\n    address indexed marketAddress,\\n    address indexed exchanger,\\n    uint baseSwapped,\\n    uint quoteReceived\\n  );\\n  /**\\n   * @dev Emitted when an exchange for quote to base occurs.\\n   * Which base and quote were swapped can be determined by the given marketAddress.\\n   */\\n  event QuoteSwappedForBase(\\n    address indexed marketAddress,\\n    address indexed exchanger,\\n    uint quoteSwapped,\\n    uint baseReceived\\n  );\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  // Admin\\n  error InvalidRewardAddress(address thrower, address rewardAddress);\\n\\n  // Market Paused\\n  error AllMarketsPaused(address thrower, address marketAddress);\\n  error MarketIsPaused(address thrower, address marketAddress);\\n\\n  // Exchanging\\n  error ReceivedZeroFromExchange(\\n    address thrower,\\n    bytes32 fromKey,\\n    bytes32 toKey,\\n    uint amountSwapped,\\n    uint amountReceived\\n  );\\n  error QuoteBaseExchangeExceedsLimit(\\n    address thrower,\\n    uint amountBaseRequested,\\n    uint quoteToSpend,\\n    uint quoteLimit,\\n    uint spotPrice,\\n    bytes32 quoteKey,\\n    bytes32 baseKey\\n  );\\n  error BaseQuoteExchangeExceedsLimit(\\n    address thrower,\\n    uint amountQuoteRequested,\\n    uint baseToSpend,\\n    uint baseLimit,\\n    uint spotPrice,\\n    bytes32 baseKey,\\n    bytes32 quoteKey\\n  );\\n  error RateIsInvalid(address thrower, uint spotPrice, bool invalid);\\n}\\n\",\"keccak256\":\"0x24c3151109164e9e9598001c32d8eb133a9f2cdb78f815d9a7fd82c954723378\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/libraries/BlackScholes.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"../synthetix/SignedDecimalMath.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\nimport \\\"./FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title BlackScholes\\n * @author Lyra\\n * @dev Contract to compute the black scholes price of options. Where the unit is unspecified, it should be treated as a\\n * PRECISE_DECIMAL, which has 1e27 units of precision. The default decimal matches the ethereum standard of 1e18 units\\n * of precision.\\n */\\nlibrary BlackScholes {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  struct PricesDeltaStdVega {\\n    uint callPrice;\\n    uint putPrice;\\n    int callDelta;\\n    int putDelta;\\n    uint vega;\\n    uint stdVega;\\n  }\\n\\n  /**\\n   * @param timeToExpirySec Number of seconds to the expiry of the option\\n   * @param volatilityDecimal Implied volatility over the period til expiry as a percentage\\n   * @param spotDecimal The current price of the base asset\\n   * @param strikePriceDecimal The strikePrice price of the option\\n   * @param rateDecimal The percentage risk free rate + carry cost\\n   */\\n  struct BlackScholesInputs {\\n    uint timeToExpirySec;\\n    uint volatilityDecimal;\\n    uint spotDecimal;\\n    uint strikePriceDecimal;\\n    int rateDecimal;\\n  }\\n\\n  uint private constant SECONDS_PER_YEAR = 31536000;\\n  /// @dev Internally this library uses 27 decimals of precision\\n  uint private constant PRECISE_UNIT = 1e27;\\n  uint private constant SQRT_TWOPI = 2506628274631000502415765285;\\n  /// @dev Below this value, return 0\\n  int private constant MIN_CDF_STD_DIST_INPUT = (int(PRECISE_UNIT) * -45) / 10; // -4.5\\n  /// @dev Above this value, return 1\\n  int private constant MAX_CDF_STD_DIST_INPUT = int(PRECISE_UNIT) * 10;\\n  /// @dev Value to use to avoid any division by 0 or values near 0\\n  uint private constant MIN_T_ANNUALISED = PRECISE_UNIT / SECONDS_PER_YEAR; // 1 second\\n  uint private constant MIN_VOLATILITY = PRECISE_UNIT / 10000; // 0.001%\\n  uint private constant VEGA_STANDARDISATION_MIN_DAYS = 7 days;\\n  /// @dev Magic numbers for normal CDF\\n  uint private constant SPLIT = 7071067811865470000000000000;\\n  uint private constant N0 = 220206867912376000000000000000;\\n  uint private constant N1 = 221213596169931000000000000000;\\n  uint private constant N2 = 112079291497871000000000000000;\\n  uint private constant N3 = 33912866078383000000000000000;\\n  uint private constant N4 = 6373962203531650000000000000;\\n  uint private constant N5 = 700383064443688000000000000;\\n  uint private constant N6 = 35262496599891100000000000;\\n  uint private constant M0 = 440413735824752000000000000000;\\n  uint private constant M1 = 793826512519948000000000000000;\\n  uint private constant M2 = 637333633378831000000000000000;\\n  uint private constant M3 = 296564248779674000000000000000;\\n  uint private constant M4 = 86780732202946100000000000000;\\n  uint private constant M5 = 16064177579207000000000000000;\\n  uint private constant M6 = 1755667163182640000000000000;\\n  uint private constant M7 = 88388347648318400000000000;\\n\\n  /////////////////////////////////////\\n  // Option Pricing public functions //\\n  /////////////////////////////////////\\n\\n  /**\\n   * @dev Returns call and put prices for options with given parameters.\\n   */\\n  function optionPrices(BlackScholesInputs memory bsInput) public pure returns (uint call, uint put) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n    uint strikePricePrecise = bsInput.strikePriceDecimal.decimalToPreciseDecimal();\\n    int ratePrecise = bsInput.rateDecimal.decimalToPreciseDecimal();\\n    (int d1, int d2) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      strikePricePrecise,\\n      ratePrecise\\n    );\\n    (call, put) = _optionPrices(tAnnualised, spotPrecise, strikePricePrecise, ratePrecise, d1, d2);\\n    return (call.preciseDecimalToDecimal(), put.preciseDecimalToDecimal());\\n  }\\n\\n  /**\\n   * @dev Returns call/put prices and delta/stdVega for options with given parameters.\\n   */\\n  function pricesDeltaStdVega(BlackScholesInputs memory bsInput) public pure returns (PricesDeltaStdVega memory) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, int d2) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n    (uint callPrice, uint putPrice) = _optionPrices(\\n      tAnnualised,\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal(),\\n      d1,\\n      d2\\n    );\\n    (uint vegaPrecise, uint stdVegaPrecise) = _standardVega(d1, spotPrecise, bsInput.timeToExpirySec);\\n    (int callDelta, int putDelta) = _delta(d1);\\n\\n    return\\n      PricesDeltaStdVega(\\n        callPrice.preciseDecimalToDecimal(),\\n        putPrice.preciseDecimalToDecimal(),\\n        callDelta.preciseDecimalToDecimal(),\\n        putDelta.preciseDecimalToDecimal(),\\n        vegaPrecise.preciseDecimalToDecimal(),\\n        stdVegaPrecise.preciseDecimalToDecimal()\\n      );\\n  }\\n\\n  /**\\n   * @dev Returns call delta given parameters.\\n   */\\n\\n  function delta(BlackScholesInputs memory bsInput) public pure returns (int callDeltaDecimal, int putDeltaDecimal) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, ) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n\\n    (int callDelta, int putDelta) = _delta(d1);\\n    return (callDelta.preciseDecimalToDecimal(), putDelta.preciseDecimalToDecimal());\\n  }\\n\\n  /**\\n   * @dev Returns non-normalized vega given parameters. Quoted in cents.\\n   */\\n  function vega(BlackScholesInputs memory bsInput) public pure returns (uint vegaDecimal) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, ) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n    return _vega(tAnnualised, spotPrecise, d1).preciseDecimalToDecimal();\\n  }\\n\\n  //////////////////////\\n  // Computing Greeks //\\n  //////////////////////\\n\\n  /**\\n   * @dev Returns internal coefficients of the Black-Scholes call price formula, d1 and d2.\\n   * @param tAnnualised Number of years to expiry\\n   * @param volatility Implied volatility over the period til expiry as a percentage\\n   * @param spot The current price of the base asset\\n   * @param strikePrice The strikePrice price of the option\\n   * @param rate The percentage risk free rate + carry cost\\n   */\\n  function _d1d2(\\n    uint tAnnualised,\\n    uint volatility,\\n    uint spot,\\n    uint strikePrice,\\n    int rate\\n  ) internal pure returns (int d1, int d2) {\\n    // Set minimum values for tAnnualised and volatility to not break computation in extreme scenarios\\n    // These values will result in option prices reflecting only the difference in stock/strikePrice, which is expected.\\n    // This should be caught before calling this function, however the function shouldn't break if the values are 0.\\n    tAnnualised = tAnnualised < MIN_T_ANNUALISED ? MIN_T_ANNUALISED : tAnnualised;\\n    volatility = volatility < MIN_VOLATILITY ? MIN_VOLATILITY : volatility;\\n\\n    int vtSqrt = int(volatility.multiplyDecimalRoundPrecise(_sqrtPrecise(tAnnualised)));\\n    int log = FixedPointMathLib.lnPrecise(int(spot.divideDecimalRoundPrecise(strikePrice)));\\n    int v2t = (int(volatility.multiplyDecimalRoundPrecise(volatility) / 2) + rate).multiplyDecimalRoundPrecise(\\n      int(tAnnualised)\\n    );\\n    d1 = (log + v2t).divideDecimalRoundPrecise(vtSqrt);\\n    d2 = d1 - vtSqrt;\\n  }\\n\\n  /**\\n   * @dev Internal coefficients of the Black-Scholes call price formula.\\n   * @param tAnnualised Number of years to expiry\\n   * @param spot The current price of the base asset\\n   * @param strikePrice The strikePrice price of the option\\n   * @param rate The percentage risk free rate + carry cost\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param d2 Internal coefficient of Black-Scholes\\n   */\\n  function _optionPrices(\\n    uint tAnnualised,\\n    uint spot,\\n    uint strikePrice,\\n    int rate,\\n    int d1,\\n    int d2\\n  ) internal pure returns (uint call, uint put) {\\n    uint strikePricePV = strikePrice.multiplyDecimalRoundPrecise(\\n      FixedPointMathLib.expPrecise(int(-rate.multiplyDecimalRoundPrecise(int(tAnnualised))))\\n    );\\n    uint spotNd1 = spot.multiplyDecimalRoundPrecise(_stdNormalCDF(d1));\\n    uint strikePriceNd2 = strikePricePV.multiplyDecimalRoundPrecise(_stdNormalCDF(d2));\\n\\n    // We clamp to zero if the minuend is less than the subtrahend\\n    // In some scenarios it may be better to compute put price instead and derive call from it depending on which way\\n    // around is more precise.\\n    call = strikePriceNd2 <= spotNd1 ? spotNd1 - strikePriceNd2 : 0;\\n    put = call + strikePricePV;\\n    put = spot <= put ? put - spot : 0;\\n  }\\n\\n  /*\\n   * Greeks\\n   */\\n\\n  /**\\n   * @dev Returns the option's delta value\\n   * @param d1 Internal coefficient of Black-Scholes\\n   */\\n  function _delta(int d1) internal pure returns (int callDelta, int putDelta) {\\n    callDelta = int(_stdNormalCDF(d1));\\n    putDelta = callDelta - int(PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Returns the option's vega value based on d1. Quoted in cents.\\n   *\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param tAnnualised Number of years to expiry\\n   * @param spot The current price of the base asset\\n   */\\n  function _vega(\\n    uint tAnnualised,\\n    uint spot,\\n    int d1\\n  ) internal pure returns (uint) {\\n    return _sqrtPrecise(tAnnualised).multiplyDecimalRoundPrecise(_stdNormal(d1).multiplyDecimalRoundPrecise(spot));\\n  }\\n\\n  /**\\n   * @dev Returns the option's vega value with expiry modified to be at least VEGA_STANDARDISATION_MIN_DAYS\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param spot The current price of the base asset\\n   * @param timeToExpirySec Number of seconds to expiry\\n   */\\n  function _standardVega(\\n    int d1,\\n    uint spot,\\n    uint timeToExpirySec\\n  ) internal pure returns (uint, uint) {\\n    uint tAnnualised = _annualise(timeToExpirySec);\\n    uint normalisationFactor = _getVegaNormalisationFactorPrecise(timeToExpirySec);\\n    uint vegaPrecise = _vega(tAnnualised, spot, d1);\\n    return (vegaPrecise, vegaPrecise.multiplyDecimalRoundPrecise(normalisationFactor));\\n  }\\n\\n  function _getVegaNormalisationFactorPrecise(uint timeToExpirySec) internal pure returns (uint) {\\n    timeToExpirySec = timeToExpirySec < VEGA_STANDARDISATION_MIN_DAYS ? VEGA_STANDARDISATION_MIN_DAYS : timeToExpirySec;\\n    uint daysToExpiry = timeToExpirySec / 1 days;\\n    uint thirty = 30 * PRECISE_UNIT;\\n    return _sqrtPrecise(thirty / daysToExpiry) / 100;\\n  }\\n\\n  /////////////////////\\n  // Math Operations //\\n  /////////////////////\\n\\n  /**\\n   * @dev Compute the absolute value of `val`.\\n   *\\n   * @param val The number to absolute value.\\n   */\\n  function _abs(int val) internal pure returns (uint) {\\n    return uint(val < 0 ? -val : val);\\n  }\\n\\n  /// @notice Calculates the square root of x, rounding down (borrowed from https://github.com/paulrberg/prb-math)\\n  /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n  /// @param x The uint256 number for which to calculate the square root.\\n  /// @return result The result as an uint256.\\n  function _sqrt(uint x) internal pure returns (uint result) {\\n    if (x == 0) {\\n      return 0;\\n    }\\n\\n    // Calculate the square root of the perfect square of a power of two that is the closest to x.\\n    uint xAux = uint(x);\\n    result = 1;\\n    if (xAux >= 0x100000000000000000000000000000000) {\\n      xAux >>= 128;\\n      result <<= 64;\\n    }\\n    if (xAux >= 0x10000000000000000) {\\n      xAux >>= 64;\\n      result <<= 32;\\n    }\\n    if (xAux >= 0x100000000) {\\n      xAux >>= 32;\\n      result <<= 16;\\n    }\\n    if (xAux >= 0x10000) {\\n      xAux >>= 16;\\n      result <<= 8;\\n    }\\n    if (xAux >= 0x100) {\\n      xAux >>= 8;\\n      result <<= 4;\\n    }\\n    if (xAux >= 0x10) {\\n      xAux >>= 4;\\n      result <<= 2;\\n    }\\n    if (xAux >= 0x8) {\\n      result <<= 1;\\n    }\\n\\n    // The operations can never overflow because the result is max 2^127 when it enters this block.\\n    unchecked {\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1; // Seven iterations should be enough\\n      uint roundedDownResult = x / result;\\n      return result >= roundedDownResult ? roundedDownResult : result;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the square root of the value using Newton's method.\\n   */\\n  function _sqrtPrecise(uint x) internal pure returns (uint) {\\n    // Add in an extra unit factor for the square root to gobble;\\n    // otherwise, sqrt(x * UNIT) = sqrt(x) * sqrt(UNIT)\\n    return _sqrt(x * PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev The standard normal distribution of the value.\\n   */\\n  function _stdNormal(int x) internal pure returns (uint) {\\n    return\\n      FixedPointMathLib.expPrecise(int(-x.multiplyDecimalRoundPrecise(x / 2))).divideDecimalRoundPrecise(SQRT_TWOPI);\\n  }\\n\\n  /**\\n   * @dev The standard normal cumulative distribution of the value.\\n   * borrowed from a C++ implementation https://stackoverflow.com/a/23119456\\n   */\\n  function _stdNormalCDF(int x) public pure returns (uint) {\\n    uint z = _abs(x);\\n    int c;\\n\\n    if (z <= 37 * PRECISE_UNIT) {\\n      uint e = FixedPointMathLib.expPrecise(-int(z.multiplyDecimalRoundPrecise(z / 2)));\\n      if (z < SPLIT) {\\n        c = int(\\n          (_stdNormalCDFNumerator(z).divideDecimalRoundPrecise(_stdNormalCDFDenom(z)).multiplyDecimalRoundPrecise(e))\\n        );\\n      } else {\\n        uint f = (z +\\n          PRECISE_UNIT.divideDecimalRoundPrecise(\\n            z +\\n              (2 * PRECISE_UNIT).divideDecimalRoundPrecise(\\n                z +\\n                  (3 * PRECISE_UNIT).divideDecimalRoundPrecise(\\n                    z + (4 * PRECISE_UNIT).divideDecimalRoundPrecise(z + ((PRECISE_UNIT * 13) / 20))\\n                  )\\n              )\\n          ));\\n        c = int(e.divideDecimalRoundPrecise(f.multiplyDecimalRoundPrecise(SQRT_TWOPI)));\\n      }\\n    }\\n    return uint((x <= 0 ? c : (int(PRECISE_UNIT) - c)));\\n  }\\n\\n  /**\\n   * @dev Helper for _stdNormalCDF\\n   */\\n  function _stdNormalCDFNumerator(uint z) internal pure returns (uint) {\\n    uint numeratorInner = ((((((N6 * z) / PRECISE_UNIT + N5) * z) / PRECISE_UNIT + N4) * z) / PRECISE_UNIT + N3);\\n    return (((((numeratorInner * z) / PRECISE_UNIT + N2) * z) / PRECISE_UNIT + N1) * z) / PRECISE_UNIT + N0;\\n  }\\n\\n  /**\\n   * @dev Helper for _stdNormalCDF\\n   */\\n  function _stdNormalCDFDenom(uint z) internal pure returns (uint) {\\n    uint denominatorInner = ((((((M7 * z) / PRECISE_UNIT + M6) * z) / PRECISE_UNIT + M5) * z) / PRECISE_UNIT + M4);\\n    return\\n      (((((((denominatorInner * z) / PRECISE_UNIT + M3) * z) / PRECISE_UNIT + M2) * z) / PRECISE_UNIT + M1) * z) /\\n      PRECISE_UNIT +\\n      M0;\\n  }\\n\\n  /**\\n   * @dev Converts an integer number of seconds to a fractional number of years.\\n   */\\n  function _annualise(uint secs) internal pure returns (uint yearFraction) {\\n    return secs.divideDecimalRoundPrecise(SECONDS_PER_YEAR);\\n  }\\n}\\n\",\"keccak256\":\"0x9ae7c895353ca808cc6b9833b9ff6a9600f11086de655e4524fe26957a053db0\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/libraries/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.9;\\n\\n// Slightly modified version of:\\n// - https://github.com/recmo/experiment-solexp/blob/605738f3ed72d6c67a414e992be58262fbc9bb80/src/FixedPointMathLib.sol\\nlibrary FixedPointMathLib {\\n  /// @dev Computes ln(x) for a 1e27 fixed point. Loses 9 last significant digits of precision.\\n  function lnPrecise(int x) internal pure returns (int r) {\\n    return ln(x / 1e9) * 1e9;\\n  }\\n\\n  /// @dev Computes e ^ x for a 1e27 fixed point. Loses 9 last significant digits of precision.\\n  function expPrecise(int x) internal pure returns (uint r) {\\n    return exp(x / 1e9) * 1e9;\\n  }\\n\\n  // Computes ln(x) in 1e18 fixed point.\\n  // Reverts if x is negative or zero.\\n  // Consumes 670 gas.\\n  function ln(int x) internal pure returns (int r) {\\n    unchecked {\\n      if (x < 1) {\\n        if (x < 0) revert LnNegativeUndefined();\\n        revert Overflow();\\n      }\\n\\n      // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n      // We do this by multiplying by 2**96 / 10**18.\\n      // But since ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n      // and add ln(2**96 / 10**18) at the end.\\n\\n      // Reduce range of x to (1, 2) * 2**96\\n      // ln(2^k * x) = k * ln(2) + ln(x)\\n      // Note: inlining ilog2 saves 8 gas.\\n      int k = int(ilog2(uint(x))) - 96;\\n      x <<= uint(159 - k);\\n      x = int(uint(x) >> 159);\\n\\n      // Evaluate using a (8, 8)-term rational approximation\\n      // p is made monic, we will multiply by a scale factor later\\n      int p = x + 3273285459638523848632254066296;\\n      p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n      p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n      p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n      p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n      p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n      p = p * x - (795164235651350426258249787498 << 96);\\n      //emit log_named_int(\\\"p\\\", p);\\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n      // q is monic by convention\\n      int q = x + 5573035233440673466300451813936;\\n      q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n      q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n      q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n      q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n      q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n      q = ((q * x) >> 96) + 909429971244387300277376558375;\\n      assembly {\\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\\n        // No scaling required because p is already 2**96 too large.\\n        r := sdiv(p, q)\\n      }\\n      // r is in the range (0, 0.125) * 2**96\\n\\n      // Finalization, we need to\\n      // * multiply by the scale factor s = 5.549\\u2026\\n      // * add ln(2**96 / 10**18)\\n      // * add k * ln(2)\\n      // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n      // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n      r *= 1677202110996718588342820967067443963516166;\\n      // add ln(2) * k * 5e18 * 2**192\\n      r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n      // add ln(2**96 / 10**18) * 5e18 * 2**192\\n      r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n      // base conversion: mul 2**18 / 2**192\\n      r >>= 174;\\n    }\\n  }\\n\\n  // Integer log2\\n  // @returns floor(log2(x)) if x is nonzero, otherwise 0. This is the same\\n  //          as the location of the highest set bit.\\n  // Consumes 232 gas. This could have been an 3 gas EVM opcode though.\\n  function ilog2(uint x) internal pure returns (uint r) {\\n    assembly {\\n      r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n      r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n      r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n      r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n      r := or(r, shl(3, lt(0xff, shr(r, x))))\\n      r := or(r, shl(2, lt(0xf, shr(r, x))))\\n      r := or(r, shl(1, lt(0x3, shr(r, x))))\\n      r := or(r, lt(0x1, shr(r, x)))\\n    }\\n  }\\n\\n  // Computes e^x in 1e18 fixed point.\\n  function exp(int x) internal pure returns (uint r) {\\n    unchecked {\\n      // Input x is in fixed point format, with scale factor 1/1e18.\\n\\n      // When the result is < 0.5 we return zero. This happens when\\n      // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n      if (x <= -42139678854452767551) {\\n        return 0;\\n      }\\n\\n      // When the result is > (2**255 - 1) / 1e18 we can not represent it\\n      // as an int256. This happens when x >= floor(log((2**255 -1) / 1e18) * 1e18) ~ 135.\\n      if (x >= 135305999368893231589) revert ExpOverflow();\\n\\n      // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n      // for more intermediate precision and a binary basis. This base conversion\\n      // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n      x = (x << 78) / 5**18;\\n\\n      // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers of two\\n      // such that exp(x) = exp(x') * 2**k, where k is an integer.\\n      // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n      int k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n      x = x - k * 54916777467707473351141471128;\\n      // k is in the range [-61, 195].\\n\\n      // Evaluate using a (6, 7)-term rational approximation\\n      // p is made monic, we will multiply by a scale factor later\\n      int p = x + 2772001395605857295435445496992;\\n      p = ((p * x) >> 96) + 44335888930127919016834873520032;\\n      p = ((p * x) >> 96) + 398888492587501845352592340339721;\\n      p = ((p * x) >> 96) + 1993839819670624470859228494792842;\\n      p = p * x + (4385272521454847904632057985693276 << 96);\\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n      // Evaluate using using Knuth's scheme from p. 491.\\n      int z = x + 750530180792738023273180420736;\\n      z = ((z * x) >> 96) + 32788456221302202726307501949080;\\n      int w = x - 2218138959503481824038194425854;\\n      w = ((w * z) >> 96) + 892943633302991980437332862907700;\\n      int q = z + w - 78174809823045304726920794422040;\\n      q = ((q * w) >> 96) + 4203224763890128580604056984195872;\\n      assembly {\\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\\n        // No scaling required because p is already 2**96 too large.\\n        r := sdiv(p, q)\\n      }\\n      // r should be in the range (0.09, 0.25) * 2**96.\\n\\n      // We now need to multiply r by\\n      //  * the scale factor s = ~6.031367120...,\\n      //  * the 2**k factor from the range reduction, and\\n      //  * the 1e18 / 2**96 factor for base converison.\\n      // We do all of this at once, with an intermediate result in 2**213 basis\\n      // so the final right shift is always by a positive amount.\\n      r = (uint(r) * 3822833074963236453042738258902158003155416615667) >> uint(195 - k);\\n    }\\n  }\\n\\n  error Overflow();\\n  error ExpOverflow();\\n  error LnNegativeUndefined();\\n}\\n\",\"keccak256\":\"0x832a2803db82c873a51e6b2c05f05484a5765a25a4f2262b0a030478c5370cf6\",\"license\":\"UNLICENSED\"},\"@lyrafinance/protocol/contracts/libraries/GWAV.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"../synthetix/SignedDecimalMath.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\nimport \\\"./FixedPointMathLib.sol\\\";\\n\\n/**\\n * @title Geometric Moving Average Oracle\\n * @author Lyra\\n * @dev Instances of stored oracle data, \\\"observations\\\", are collected in the oracle array\\n *\\n * The GWAV values are calculated from the blockTimestamps and \\\"q\\\" accumulator values of two Observations. When\\n * requested the closest observations are scaled to the requested timestamp.\\n */\\nlibrary GWAV {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  /// @dev Stores all past Observations and the current index\\n  struct Params {\\n    Observation[] observations;\\n    uint index;\\n  }\\n\\n  /// @dev An observation holds the cumulative log value of all historic observations (accumulator)\\n  /// and other relevant fields for computing the next accumulator value.\\n  /// @dev A pair of oracle Observations is used to deduce the GWAV TWAP\\n  struct Observation {\\n    int q; // accumulator value used to compute GWAV\\n    uint nextVal; // value at the time the observation was made, used to calculate the next q value\\n    uint blockTimestamp;\\n  }\\n\\n  /////////////\\n  // Setters //\\n  /////////////\\n\\n  /**\\n   * @notice Initialize the oracle array by writing the first Observation.\\n   * @dev Called once for the lifecycle of the observations array\\n   * @dev First Observation uses blockTimestamp as the time interval to prevent manipulation of the GWAV immediately\\n   * after initialization\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param newVal First observed value for blockTimestamp\\n   * @param blockTimestamp Timestamp of first Observation\\n   */\\n  function _initialize(\\n    Params storage self,\\n    uint newVal,\\n    uint blockTimestamp\\n  ) internal {\\n    // if Observation older than blockTimestamp is used for GWAV,\\n    // _getFirstBefore() will scale the first Observation \\\"q\\\" accordingly\\n    _initializeWithManualQ(self, FixedPointMathLib.ln((int(newVal))) * int(blockTimestamp), newVal, blockTimestamp);\\n  }\\n\\n  /**\\n   * @notice Writes an oracle Observation to the GWAV array\\n   * @dev Writable at most once per block. BlockTimestamp must be > last.blockTimestamp\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param nextVal Value at given blockTimestamp\\n   * @param blockTimestamp Current blockTimestamp\\n   */\\n  function _write(\\n    Params storage self,\\n    uint nextVal,\\n    uint blockTimestamp\\n  ) internal {\\n    Observation memory last = self.observations[self.index];\\n\\n    // Ensure entries are sequential\\n    if (blockTimestamp < last.blockTimestamp) {\\n      revert InvalidBlockTimestamp(address(this), blockTimestamp, last.blockTimestamp);\\n    }\\n\\n    // early return if we've already written an observation this block\\n    if (last.blockTimestamp == blockTimestamp) {\\n      self.observations[self.index].nextVal = nextVal;\\n      return;\\n    }\\n    // No reason to record an entry if it's the same as the last one\\n    if (last.nextVal == nextVal) return;\\n\\n    // update accumulator value\\n    // assumes the market value between the previous and current blockTimstamps was \\\"last.nextVal\\\"\\n    uint timestampDelta = blockTimestamp - last.blockTimestamp;\\n    int newQ = last.q + FixedPointMathLib.ln((int(last.nextVal))) * int(timestampDelta);\\n\\n    // update latest index and store Observation\\n    uint indexUpdated = (self.index + 1);\\n    self.observations.push(_transform(newQ, nextVal, blockTimestamp));\\n    self.index = indexUpdated;\\n  }\\n\\n  /////////////\\n  // Getters //\\n  /////////////\\n\\n  /**\\n   * @notice Calculates the geometric moving average between two Observations A & B. These observations are scaled to\\n   * the requested timestamps\\n   * @dev For the current GWAV value, \\\"0\\\" may be passed in for secondsAgo\\n   * @dev If timestamps A==B, returns the value at A/B.\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param secondsAgoA Seconds from blockTimestamp to Observation A\\n   * @param secondsAgoB Seconds from blockTimestamp to Observation B\\n   */\\n  function getGWAVForPeriod(\\n    Params storage self,\\n    uint secondsAgoA,\\n    uint secondsAgoB\\n  ) public view returns (uint) {\\n    (int q0, uint t0) = queryFirstBeforeAndScale(self, block.timestamp, secondsAgoA);\\n    (int q1, uint t1) = queryFirstBeforeAndScale(self, block.timestamp, secondsAgoB);\\n\\n    if (t0 == t1) {\\n      return uint(FixedPointMathLib.exp(q1 / int(t1)));\\n    }\\n\\n    return uint(FixedPointMathLib.exp((q1 - q0) / int(t1 - t0)));\\n  }\\n\\n  /**\\n   * @notice Returns the GWAV accumulator/timestamps values for each \\\"secondsAgo\\\" in the array `secondsAgos[]`\\n   * @param currentBlockTimestamp Timestamp of current block\\n   * @param secondsAgos Array of all timestamps for which to export accumulator/timestamp values\\n   */\\n  function observe(\\n    Params storage self,\\n    uint currentBlockTimestamp,\\n    uint[] memory secondsAgos\\n  ) public view returns (int[] memory qCumulatives, uint[] memory timestamps) {\\n    uint secondsAgosLength = secondsAgos.length;\\n    qCumulatives = new int[](secondsAgosLength);\\n    timestamps = new uint[](secondsAgosLength);\\n    for (uint i = 0; i < secondsAgosLength; ++i) {\\n      (qCumulatives[i], timestamps[i]) = queryFirstBefore(self, currentBlockTimestamp, secondsAgos[i]);\\n    }\\n  }\\n\\n  //////////////////////////////////////////////////////\\n  // Querying observation closest to target timestamp //\\n  //////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Finds the first observation before a timestamp \\\"secondsAgo\\\" from the \\\"currentBlockTimestamp\\\"\\n   * @dev If target falls between two Observations, the older one is returned\\n   * @dev See _queryFirstBefore() for edge cases where target lands\\n   * after the newest Observation or before the oldest Observation\\n   * @dev Reverts if secondsAgo exceeds the currentBlockTimestamp\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param currentBlockTimestamp Timestamp of current block\\n   * @param secondsAgo Seconds from currentBlockTimestamp to target Observation\\n   */\\n  function queryFirstBefore(\\n    Params storage self,\\n    uint currentBlockTimestamp,\\n    uint secondsAgo\\n  ) internal view returns (int qCumulative, uint timestamp) {\\n    uint target = currentBlockTimestamp - secondsAgo;\\n    Observation memory beforeOrAt = _queryFirstBefore(self, target);\\n\\n    return (beforeOrAt.q, beforeOrAt.blockTimestamp);\\n  }\\n\\n  function queryFirstBeforeAndScale(\\n    Params storage self,\\n    uint currentBlockTimestamp,\\n    uint secondsAgo\\n  ) internal view returns (int qCumulative, uint timestamp) {\\n    uint target = currentBlockTimestamp - secondsAgo;\\n    Observation memory beforeOrAt = _queryFirstBefore(self, target);\\n\\n    int timestampDelta = int(target - beforeOrAt.blockTimestamp);\\n\\n    return (beforeOrAt.q + (FixedPointMathLib.ln(int(beforeOrAt.nextVal)) * timestampDelta), target);\\n  }\\n\\n  /**\\n   * @notice Finds the first observation before the \\\"target\\\" timestamp\\n   * @dev Checks for trivial scenarios before entering _binarySearch()\\n   * @dev Assumes _initialize() has been called\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param target BlockTimestamp of target Observation\\n   */\\n  function _queryFirstBefore(Params storage self, uint target) private view returns (Observation memory beforeOrAt) {\\n    // Case 1: target blockTimestamp is at or after the most recent Observation\\n    beforeOrAt = self.observations[self.index];\\n    if (beforeOrAt.blockTimestamp <= target) {\\n      return (beforeOrAt);\\n    }\\n\\n    // Now, set to the oldest observation\\n    beforeOrAt = self.observations[0];\\n\\n    // Case 2: target blockTimestamp is older than the oldest Observation\\n    // The observation is scaled to the target using the nextVal\\n    if (beforeOrAt.blockTimestamp > target) {\\n      return _transform((beforeOrAt.q * int(target)) / int(beforeOrAt.blockTimestamp), beforeOrAt.nextVal, target);\\n    }\\n\\n    // Case 3: target is within the recorded Observations.\\n    return self.observations[_binarySearch(self, target)];\\n  }\\n\\n  /**\\n   * @notice Finds closest Observation before target using binary search and returns its index\\n   * @dev Used when the target is located within the stored observation boundaries\\n   * e.g. Older than the most recent observation and younger, or the same age as, the oldest observation\\n   * @return foundIndex Returns the Observation which is older than target (instead of newer)\\n   * @param self Stores past Observations and the index of the latest Observation\\n   * @param target BlockTimestamp of target Observation\\n   */\\n  function _binarySearch(Params storage self, uint target) internal view returns (uint) {\\n    uint oldest = 0; // oldest observation\\n    uint newest = self.index; // newest observation\\n    uint i;\\n    while (true) {\\n      i = (oldest + newest) / 2;\\n      uint beforeOrAtTimestamp = self.observations[i].blockTimestamp;\\n\\n      uint atOrAfterTimestamp = self.observations[i + 1].blockTimestamp;\\n      bool targetAtOrAfter = beforeOrAtTimestamp <= target;\\n\\n      // check if we've found the answer!\\n      if (targetAtOrAfter && target <= atOrAfterTimestamp) break;\\n\\n      if (!targetAtOrAfter) {\\n        newest = i - 1;\\n      } else {\\n        oldest = i + 1;\\n      }\\n    }\\n\\n    return i;\\n  }\\n\\n  /////////////\\n  // Utility //\\n  /////////////\\n\\n  /**\\n   * @notice Creates the first Observation with manual Q accumulator value.\\n   * @param qVal Initial GWAV accumulator value\\n   * @param nextVal First observed value for blockTimestamp\\n   * @param blockTimestamp Timestamp of Observation\\n   */\\n  function _initializeWithManualQ(\\n    Params storage self,\\n    int qVal,\\n    uint nextVal,\\n    uint blockTimestamp\\n  ) internal {\\n    self.observations.push(Observation({q: qVal, nextVal: nextVal, blockTimestamp: blockTimestamp}));\\n  }\\n\\n  /**\\n   * @dev Creates an Observation given a GWAV accumulator, latest value, and a blockTimestamp\\n   */\\n  function _transform(\\n    int newQ,\\n    uint nextVal,\\n    uint blockTimestamp\\n  ) private pure returns (Observation memory) {\\n    return Observation({q: newQ, nextVal: nextVal, blockTimestamp: blockTimestamp});\\n  }\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  error InvalidBlockTimestamp(address thrower, uint timestamp, uint lastObservedTimestamp);\\n}\\n\",\"keccak256\":\"0xd8973ceb7907d8d1cd89642b54783ad1bf20c8df5c90b7e6a80ef8e07825e50f\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/BasicFeeCounter.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\npragma solidity 0.8.9;\\n\\nimport \\\"../synthetix/Owned.sol\\\";\\nimport \\\"../interfaces/IFeeCounter.sol\\\";\\n\\n/**\\n * @title BasicFeeCounter\\n */\\ncontract BasicFeeCounter is IFeeCounter, Owned {\\n  mapping(address => bool) public trustedCounter;\\n  mapping(address => mapping(address => uint)) public totalFeesPerMarket;\\n\\n  constructor() Owned() {}\\n\\n  function setTrustedCounter(address counter, bool isTrusted) external onlyOwner {\\n    trustedCounter[counter] = isTrusted;\\n  }\\n\\n  function trackFee(\\n    address market,\\n    address trader,\\n    uint,\\n    uint,\\n    uint totalFee\\n  ) external onlyTrustedCounter {\\n    totalFeesPerMarket[market][trader] += totalFee;\\n  }\\n\\n  modifier onlyTrustedCounter() {\\n    require(trustedCounter[msg.sender], \\\"not trusted counter\\\");\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x34d4f62d40ab6941693c3687c2f568d09493c7536dcdf9bbfceac78cfe72d81d\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/periphery/LyraAdapter.sol\":{\"content\":\"//SPDX-License-Identifier:ISC\\npragma solidity 0.8.9;\\n\\n// Libraries\\nimport \\\"../libraries/GWAV.sol\\\";\\nimport \\\"../libraries/BlackScholes.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\n\\n// Inherited\\nimport \\\"openzeppelin-contracts-4.4.1/access/Ownable.sol\\\";\\nimport \\\"openzeppelin-contracts-4.4.1/token/ERC20/IERC20.sol\\\";\\n\\n// Interfaces\\nimport \\\"../interfaces/IOptionToken.sol\\\";\\nimport \\\"../interfaces/IOptionMarket.sol\\\";\\nimport \\\"../interfaces/ILiquidityPool.sol\\\";\\nimport \\\"../interfaces/IShortCollateral.sol\\\";\\nimport \\\"../interfaces/IOptionGreekCache.sol\\\";\\nimport \\\"../interfaces/ISynthetixAdapter.sol\\\";\\nimport \\\"../interfaces/IDelegateApprovals.sol\\\";\\nimport \\\"../interfaces/ICurve.sol\\\";\\nimport \\\"../interfaces/IGWAVOracle.sol\\\";\\nimport \\\"../interfaces/ILyraRegistry.sol\\\";\\nimport \\\"./BasicFeeCounter.sol\\\";\\n\\n/**\\n * @title LyraAdapter\\n * @author Lyra\\n * @dev Provides helpful functions for any Lyra trading/market data/vault related actions in one contract\\n *      To earn trading rewards, integrators must request to be whitelisted by Lyra\\n */\\n\\ncontract LyraAdapter is Ownable {\\n  using DecimalMath for uint;\\n\\n  ///////////////////////\\n  // Abstract Contract //\\n  ///////////////////////\\n\\n  struct Strike {\\n    // strike listing identifier\\n    uint id;\\n    // expiry of strike\\n    uint expiry;\\n    // strike price\\n    uint strikePrice;\\n    // volatility component specific to the strike listing (boardIv * skew = vol of strike)\\n    uint skew;\\n    // volatility component specific to the board (boardIv * skew = vol of strike)\\n    uint boardIv;\\n  }\\n\\n  struct Board {\\n    // board identifier\\n    uint id;\\n    // expiry of all strikes belong to\\n    uint expiry;\\n    // volatility component specific to the board (boardIv * skew = vol of strike)\\n    uint boardIv;\\n    // all strikes belonging to board\\n    uint[] strikeIds;\\n  }\\n\\n  struct OptionPosition {\\n    // OptionToken ERC721 identifier for position\\n    uint positionId;\\n    // strike identifier\\n    uint strikeId;\\n    // LONG_CALL | LONG_PUT | SHORT_CALL_BASE | SHORT_CALL_QUOTE | SHORT_PUT_QUOTE\\n    OptionType optionType;\\n    // number of options contract owned by position\\n    uint amount;\\n    // collateral held in position (only applies to shorts)\\n    uint collateral;\\n    // EMPTY | ACTIVE | CLOSED | LIQUIDATED | SETTLED | MERGED\\n    PositionState state;\\n  }\\n\\n  enum OptionType {\\n    LONG_CALL,\\n    LONG_PUT,\\n    SHORT_CALL_BASE,\\n    SHORT_CALL_QUOTE,\\n    SHORT_PUT_QUOTE\\n  }\\n\\n  enum PositionState {\\n    EMPTY,\\n    ACTIVE,\\n    CLOSED,\\n    LIQUIDATED,\\n    SETTLED,\\n    MERGED\\n  }\\n\\n  struct TradeInputParameters {\\n    // id of strike\\n    uint strikeId;\\n    // OptionToken ERC721 id for position (set to 0 for new positions)\\n    uint positionId;\\n    // number of sub-orders to break order into (reduces slippage)\\n    uint iterations;\\n    // type of option to trade\\n    OptionType optionType;\\n    // number of contracts to trade\\n    uint amount;\\n    // final amount of collateral to leave in OptionToken position\\n    uint setCollateralTo;\\n    // revert trade if totalCost is below this value\\n    uint minTotalCost;\\n    // revert trade if totalCost is above this value\\n    uint maxTotalCost;\\n    // address of recipient for Lyra trading rewards (must request Lyra to be whitelisted for rewards)\\n    address rewardRecipient;\\n  }\\n\\n  struct TradeResult {\\n    // OptionToken ERC721 id for position\\n    uint positionId;\\n    // total option cost paid/received during trade including premium and totalFee\\n    uint totalCost;\\n    // trading fees as determined in OptionMarketPricer.sol\\n    uint totalFee;\\n  }\\n\\n  struct Liquidity {\\n    // Amount of liquidity available for option collateral and premiums\\n    uint freeLiquidity;\\n    // Amount of liquidity available for withdrawals - different to freeLiquidity\\n    uint burnableLiquidity;\\n    // Amount of liquidity reserved for long options sold to traders\\n    uint usedCollatLiquidity;\\n    // Portion of liquidity reserved for delta hedging (quote outstanding)\\n    uint pendingDeltaLiquidity;\\n    // Current value of delta hedge\\n    uint usedDeltaLiquidity;\\n    // Net asset value, including everything and netOptionValue\\n    uint NAV;\\n  }\\n\\n  struct MarketParams {\\n    // The amount of options traded to move baseIv for the board up or down 1 point (depending on trade direction)\\n    uint standardSize;\\n    // Determines relative move of skew for a given strike compared to shift in baseIv\\n    uint skewAdjustmentParam;\\n    // Interest/risk free rate used in BlackScholes\\n    int rateAndCarry;\\n    // Delta cutoff past which options can be traded (optionD > minD && optionD < 1 - minD) - can use forceClose to bypass\\n    int deltaCutOff;\\n    // Time when trading closes - can use forceClose to bypass\\n    uint tradingCutoff;\\n    // Delta cutoff at which forceClose can be called (optionD < minD || optionD > 1 - minD) - using call delta\\n    int minForceCloseDelta;\\n  }\\n\\n  struct ExchangeRateParams {\\n    // current snx oracle base price\\n    uint spotPrice;\\n    // snx spot exchange rate from quote to base\\n    uint quoteBaseFeeRate;\\n    // snx spot exchange rate from base to quote\\n    uint baseQuoteFeeRate;\\n  }\\n\\n  ///////////////\\n  // Variables //\\n  ///////////////\\n\\n  ILyraRegistry public lyraRegistry;\\n  ISynthetixAdapter internal synthetixAdapter;\\n  IOptionMarket public optionMarket;\\n  IOptionToken public optionToken;\\n  ILiquidityPool public liquidityPool;\\n  IShortCollateral public shortCollateral;\\n  IGWAVOracle public gwavOracle;\\n  IOptionMarketPricer public optionPricer;\\n  IOptionGreekCache public greekCache;\\n  IERC20 public quoteAsset;\\n  IERC20 public baseAsset;\\n\\n  ICurve public curveSwap;\\n  BasicFeeCounter public feeCounter;\\n  bytes32 private constant SNX_ADAPTER = \\\"SYNTHETIX_ADAPTER\\\";\\n\\n  ///////////\\n  // Admin //\\n  ///////////\\n\\n  constructor() Ownable() {}\\n\\n  /**\\n   * @dev Assigns all lyra contracts\\n\\n   * @param _lyraRegistry LyraRegistry address which holds latest market and global addressess\\n   * @param _optionMarket OptionMarket address\\n   * @param _curveSwap Curve pool address for swapping sUSD and other stables via `exchange_with_best_rate`\\n   * @param _feeCounter Fee counter addressu used to determine Lyra trading rewards\\n   */\\n\\n  function setLyraAddresses(\\n    address _lyraRegistry,\\n    address _optionMarket,\\n    address _curveSwap,\\n    address _feeCounter\\n  ) public onlyOwner {\\n    // remove allowance from old assets\\n    if (address(quoteAsset) != address(0)) {\\n      quoteAsset.approve(address(optionMarket), 0);\\n    }\\n    if (address(baseAsset) != address(0)) {\\n      baseAsset.approve(address(optionMarket), 0);\\n    }\\n\\n    optionMarket = IOptionMarket(_optionMarket);\\n\\n    // Get market & global addresses via LyraRegistry\\n    lyraRegistry = ILyraRegistry(_lyraRegistry);\\n    synthetixAdapter = ISynthetixAdapter(lyraRegistry.getGlobalAddress(SNX_ADAPTER));\\n    _assignLyraRegistryMarketAddresses();\\n\\n    // assign curve and Lyra reward counter\\n    curveSwap = ICurve(_curveSwap);\\n    feeCounter = BasicFeeCounter(_feeCounter);\\n\\n    // Do approvals\\n    IDelegateApprovals(synthetixAdapter.delegateApprovals()).approveExchangeOnBehalf(address(synthetixAdapter));\\n    quoteAsset.approve(address(optionMarket), type(uint).max);\\n    baseAsset.approve(address(optionMarket), type(uint).max);\\n  }\\n\\n  /// @notice In case of an update to the synthetix contract that revokes the approval\\n  function updateDelegateApproval() external onlyOwner {\\n    IDelegateApprovals(synthetixAdapter.delegateApprovals()).approveExchangeOnBehalf(address(synthetixAdapter));\\n  }\\n\\n  ////////////////////\\n  // Market Actions //\\n  ////////////////////\\n\\n  /**\\n   * @notice Attempts to open positions within cost bounds.\\n   * @dev If a positionId is specified params.amount will be added to the position\\n   * @dev params.amount can be zero when adjusting an existing position\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _openPosition(TradeInputParameters memory params) internal returns (TradeResult memory tradeResult) {\\n    IOptionMarket.Result memory result = optionMarket.openPosition(_convertParams(params));\\n    if (params.rewardRecipient != address(0)) {\\n      feeCounter.trackFee(\\n        address(optionMarket),\\n        params.rewardRecipient,\\n        _convertParams(params).amount,\\n        result.totalCost,\\n        result.totalFee\\n      );\\n    }\\n    return TradeResult({positionId: result.positionId, totalCost: result.totalCost, totalFee: result.totalFee});\\n  }\\n\\n  /**\\n   * @notice Attempt close under normal condition or forceClose\\n   *          if position is outside of delta or too close to expiry.\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _closeOrForceClosePosition(TradeInputParameters memory params)\\n    internal\\n    returns (TradeResult memory tradeResult)\\n  {\\n    if (!_isOutsideDeltaCutoff(params.strikeId) && !_isWithinTradingCutoff(params.strikeId)) {\\n      return _closePosition(params);\\n    } else {\\n      // will pay less competitive price to close position but bypasses Lyra delta/trading cutoffs\\n      return _forceClosePosition(params);\\n    }\\n  }\\n\\n  /**\\n   * @notice Attempts to close an existing position within cost bounds.\\n   * @dev If a positionId is specified params.amount will be subtracted from the position\\n   * @dev params.amount can be zero when adjusting an existing position\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _closePosition(TradeInputParameters memory params) internal returns (TradeResult memory tradeResult) {\\n    IOptionMarket.Result memory result = optionMarket.closePosition(_convertParams(params));\\n    if (params.rewardRecipient != address(0)) {\\n      feeCounter.trackFee(\\n        address(optionMarket),\\n        params.rewardRecipient,\\n        _convertParams(params).amount,\\n        result.totalCost,\\n        result.totalFee\\n      );\\n    }\\n    return TradeResult({positionId: result.positionId, totalCost: result.totalCost, totalFee: result.totalFee});\\n  }\\n\\n  /**\\n   * @notice Attempts to close an existing position outside of the delta or trading cutoffs (as specified in MarketParams).\\n   * @dev This market action will charge higher fees than the standard `closePosition()`\\n   *\\n   * @param params The parameters for the requested trade\\n   */\\n  function _forceClosePosition(TradeInputParameters memory params) internal returns (TradeResult memory tradeResult) {\\n    IOptionMarket.Result memory result = optionMarket.forceClosePosition(_convertParams(params));\\n    if (params.rewardRecipient != address(0)) {\\n      feeCounter.trackFee(\\n        address(optionMarket),\\n        params.rewardRecipient,\\n        _convertParams(params).amount,\\n        result.totalCost,\\n        result.totalFee\\n      );\\n    }\\n    return TradeResult({positionId: result.positionId, totalCost: result.totalCost, totalFee: result.totalFee});\\n  }\\n\\n  //////////////\\n  // Exchange //\\n  //////////////\\n\\n  /// @notice Exchange an exact amount of quote for a minimum amount of base (revert otherwise)\\n  function _exchangeFromExactQuote(uint amountQuote, uint minBaseReceived) internal returns (uint baseReceived) {\\n    baseReceived = synthetixAdapter.exchangeFromExactQuote(address(optionMarket), amountQuote);\\n    if (baseReceived < minBaseReceived) {\\n      revert ExchangerBaseReceivedTooLow(address(this), minBaseReceived, baseReceived);\\n    }\\n  }\\n\\n  /// @notice Exchange to an exact amount of quote for a maximum amount of base (revert otherwise)\\n  function _exchangeToExactQuote(uint amountQuote, uint maxBaseUsed) internal returns (uint quoteReceived) {\\n    ISynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(address(optionMarket));\\n    (, quoteReceived) = synthetixAdapter.exchangeToExactQuoteWithLimit(\\n      exchangeParams,\\n      address(optionMarket),\\n      amountQuote,\\n      maxBaseUsed\\n    );\\n  }\\n\\n  /// @notice Exchange an exact amount of base for a minimum amount of quote (revert otherwise)\\n  function _exchangeFromExactBase(uint amountBase, uint minQuoteReceived) internal returns (uint quoteReceived) {\\n    quoteReceived = synthetixAdapter.exchangeFromExactBase(address(optionMarket), amountBase);\\n    if (quoteReceived < minQuoteReceived) {\\n      revert ExchangerQuoteReceivedTooLow(address(this), minQuoteReceived, quoteReceived);\\n    }\\n  }\\n\\n  /// @notice Exchange to an exact amount of base for a maximum amount of quote (revert otherwise)\\n  function _exchangeToExactBase(uint amountBase, uint maxQuoteUsed) internal returns (uint baseReceived) {\\n    ISynthetixAdapter.ExchangeParams memory exchangeParams = synthetixAdapter.getExchangeParams(address(optionMarket));\\n    (, baseReceived) = synthetixAdapter.exchangeToExactBaseWithLimit(\\n      exchangeParams,\\n      address(optionMarket),\\n      amountBase,\\n      maxQuoteUsed\\n    );\\n  }\\n\\n  /// @notice Returns the ExchangeParams for current market.\\n  function _getExchangeParams() internal view returns (ExchangeRateParams memory) {\\n    ISynthetixAdapter.ExchangeParams memory params = synthetixAdapter.getExchangeParams(address(optionMarket));\\n    return\\n      ExchangeRateParams({\\n        spotPrice: params.spotPrice,\\n        quoteBaseFeeRate: params.quoteBaseFeeRate,\\n        baseQuoteFeeRate: params.baseQuoteFeeRate\\n      });\\n  }\\n\\n  /**\\n   * @notice WARNING: ENSURE CURVE HAS SUFFICIENT sUSD LIQUIDITY\\n   *         Exchange between stables within the curveSwap sUSD pool.\\n   *\\n   * @param from start ERC20\\n   * @param to destination ERC20\\n   * @param amount amount of \\\"from\\\" currency to exchange\\n   * @param expected minimum expected amount of \\\"to\\\" currency\\n   * @param receiver address of recipient of \\\"to\\\" currency\\n   *\\n   * @return amountOut received amount\\n   */\\n  function _swapStables(\\n    address from,\\n    address to,\\n    uint amount,\\n    uint expected,\\n    address receiver\\n  ) internal returns (uint amountOut) {\\n    amountOut = curveSwap.exchange_with_best_rate(from, to, amount, expected, receiver);\\n  }\\n\\n  //////////////////////////\\n  // Option Token Actions //\\n  //////////////////////////\\n\\n  /// @notice Get position info for given positionIds\\n  function _getPositions(uint[] memory positionIds) internal view returns (OptionPosition[] memory) {\\n    IOptionToken.OptionPosition[] memory positions = optionToken.getOptionPositions(positionIds);\\n\\n    uint positionsLen = positions.length;\\n    OptionPosition[] memory convertedPositions = new OptionPosition[](positionsLen);\\n    for (uint i = 0; i < positionsLen; ++i) {\\n      convertedPositions[i] = OptionPosition({\\n        positionId: positions[i].positionId,\\n        strikeId: positions[i].strikeId,\\n        optionType: OptionType(uint(positions[i].optionType)),\\n        amount: positions[i].amount,\\n        collateral: positions[i].collateral,\\n        state: PositionState(uint(positions[i].state))\\n      });\\n    }\\n\\n    return convertedPositions;\\n  }\\n\\n  /**\\n   * @notice Allows a user to split a curent position into two. The amount of the original position will\\n   *         be subtracted from and a new position will be minted with the desired amount and collateral.\\n   * @dev Only ACTIVE positions can be owned by users, so status does not need to be checked\\n   * @dev Both resulting positions must not be liquidatable\\n   *\\n   * @param positionId the positionId of the original position to be split\\n   * @param newAmount the amount in the new position\\n   * @param newCollateral the amount of collateral for the new position\\n   * @param recipient recipient of new position\\n   */\\n  function _splitPosition(\\n    uint positionId,\\n    uint newAmount,\\n    uint newCollateral,\\n    address recipient\\n  ) internal returns (uint newPositionId) {\\n    newPositionId = optionToken.split(positionId, newAmount, newCollateral, recipient);\\n  }\\n\\n  /**\\n   * @notice User can merge many positions with matching strike and optionType into a single position\\n   * @dev Only ACTIVE positions can be owned by users, so status does not need to be checked.\\n   * @dev Merged position must not be liquidatable.\\n   *\\n   * @param positionIds the positionIds to be merged together\\n   */\\n  function _mergePositions(uint[] memory positionIds) internal {\\n    optionToken.merge(positionIds);\\n  }\\n\\n  ////////////////////\\n  // Market Getters //\\n  ////////////////////\\n\\n  /// @notice Returns the list of live board ids.\\n  function _getLiveBoards() internal view returns (uint[] memory liveBoards) {\\n    liveBoards = optionMarket.getLiveBoards();\\n  }\\n\\n  /// @notice Returns Board struct for a given boardId\\n  function _getBoard(uint boardId) internal view returns (Board memory) {\\n    IOptionMarket.OptionBoard memory board = optionMarket.getOptionBoard(boardId);\\n    return Board({id: board.id, expiry: board.expiry, boardIv: board.iv, strikeIds: board.strikeIds});\\n  }\\n\\n  /// @notice Returns all Strike structs for a list of strikeIds\\n  function _getStrikes(uint[] memory strikeIds) internal view returns (Strike[] memory allStrikes) {\\n    uint strikesLen = strikeIds.length;\\n\\n    allStrikes = new Strike[](strikesLen);\\n    for (uint i = 0; i < strikesLen; ++i) {\\n      (IOptionMarket.Strike memory strike, IOptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(\\n        strikeIds[i]\\n      );\\n\\n      allStrikes[i] = Strike({\\n        id: strike.id,\\n        expiry: board.expiry,\\n        strikePrice: strike.strikePrice,\\n        skew: strike.skew,\\n        boardIv: board.iv\\n      });\\n    }\\n    return allStrikes;\\n  }\\n\\n  /// @notice Returns current spot volatilities for given strikeIds (boardIv * skew)\\n  function _getVols(uint[] memory strikeIds) internal view returns (uint[] memory vols) {\\n    uint strikesLen = strikeIds.length;\\n\\n    vols = new uint[](strikesLen);\\n    for (uint i = 0; i < strikesLen; ++i) {\\n      (IOptionMarket.Strike memory strike, IOptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(\\n        strikeIds[i]\\n      );\\n\\n      vols[i] = board.iv.multiplyDecimal(strike.skew);\\n    }\\n    return vols;\\n  }\\n\\n  /// @notice Returns current spot deltas for given strikeIds (using BlackScholes and spot volatilities)\\n  function _getDeltas(uint[] memory strikeIds) internal view returns (int[] memory callDeltas) {\\n    uint strikesLen = strikeIds.length;\\n\\n    callDeltas = new int[](strikesLen);\\n    for (uint i = 0; i < strikesLen; ++i) {\\n      BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeIds[i]);\\n      (callDeltas[i], ) = BlackScholes.delta(bsInput);\\n    }\\n  }\\n\\n  /// @notice Returns current spot vegas for given strikeIds (using BlackScholes and spot volatilities)\\n  function _getVegas(uint[] memory strikeIds) internal view returns (uint[] memory vegas) {\\n    uint strikesLen = strikeIds.length;\\n\\n    vegas = new uint[](strikesLen);\\n    for (uint i = 0; i < strikesLen; ++i) {\\n      BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeIds[i]);\\n      vegas[i] = BlackScholes.vega(bsInput);\\n    }\\n  }\\n\\n  /// @notice Calculate the pure black-scholes premium for given params\\n  function _getPurePremium(\\n    uint secondsToExpiry,\\n    uint vol,\\n    uint spotPrice,\\n    uint strikePrice\\n  ) internal view returns (uint call, uint put) {\\n    BlackScholes.BlackScholesInputs memory bsInput = BlackScholes.BlackScholesInputs({\\n      timeToExpirySec: secondsToExpiry,\\n      volatilityDecimal: vol,\\n      spotDecimal: spotPrice,\\n      strikePriceDecimal: strikePrice,\\n      rateDecimal: greekCache.getGreekCacheParams().rateAndCarry\\n    });\\n    (call, put) = BlackScholes.optionPrices(bsInput);\\n  }\\n\\n  /// @notice Calculate the spot black-scholes premium for a given strike\\n  /// @dev Does not include slippage or trading fees\\n  function _getPurePremiumForStrike(uint strikeId) internal view returns (uint call, uint put) {\\n    BlackScholes.BlackScholesInputs memory bsInput = _getBsInput(strikeId);\\n    (call, put) = BlackScholes.optionPrices(bsInput);\\n  }\\n\\n  /// @notice Returns the breakdown of current liquidity usage (see Liquidity struct)\\n  function _getLiquidity() internal view returns (Liquidity memory) {\\n    ILiquidityPool.Liquidity memory liquidity = liquidityPool.getCurrentLiquidity();\\n    return\\n      Liquidity({\\n        freeLiquidity: liquidity.freeLiquidity,\\n        burnableLiquidity: liquidity.burnableLiquidity,\\n        usedCollatLiquidity: liquidity.usedCollatLiquidity,\\n        pendingDeltaLiquidity: liquidity.pendingDeltaLiquidity,\\n        usedDeltaLiquidity: liquidity.usedDeltaLiquidity,\\n        NAV: liquidity.NAV\\n      });\\n  }\\n\\n  /// @notice Returns the amount of liquidity available for trading\\n  function _getFreeLiquidity() internal view returns (uint freeLiquidity) {\\n    freeLiquidity = liquidityPool.getCurrentLiquidity().freeLiquidity;\\n  }\\n\\n  /// @notice Returns the most critical Lyra market trading parameters that determine pricing/slippage/trading restrictions\\n  function _getMarketParams() internal view returns (MarketParams memory) {\\n    IOptionMarketPricer.PricingParameters memory pricingParams = optionPricer.getPricingParams();\\n    IOptionMarketPricer.TradeLimitParameters memory tradeLimitParams = optionPricer.getTradeLimitParams();\\n    return\\n      MarketParams({\\n        standardSize: pricingParams.standardSize,\\n        skewAdjustmentParam: pricingParams.skewAdjustmentFactor,\\n        rateAndCarry: greekCache.getGreekCacheParams().rateAndCarry,\\n        deltaCutOff: tradeLimitParams.minDelta,\\n        tradingCutoff: tradeLimitParams.tradingCutoff,\\n        minForceCloseDelta: tradeLimitParams.minForceCloseDelta\\n      });\\n  }\\n\\n  /// @notice use latest optionMarket delta cutoff to determine whether trade delta is out of bounds\\n  function _isOutsideDeltaCutoff(uint strikeId) internal view returns (bool) {\\n    MarketParams memory marketParams = _getMarketParams();\\n    uint[] memory dynamicArray = new uint[](1);\\n    dynamicArray[0] = strikeId;\\n\\n    int callDelta = _getDeltas(dynamicArray)[0];\\n    return callDelta > (int(DecimalMath.UNIT) - marketParams.deltaCutOff) || callDelta < marketParams.deltaCutOff;\\n  }\\n\\n  /// @notice use latest optionMarket trading cutoff to determine whether trade is too close to expiry\\n  function _isWithinTradingCutoff(uint strikeId) internal view returns (bool) {\\n    MarketParams memory marketParams = _getMarketParams();\\n    uint[] memory dynamicArray = new uint[](1);\\n    dynamicArray[0] = strikeId;\\n\\n    Strike memory strike = _getStrikes(dynamicArray)[0];\\n    return strike.expiry - block.timestamp <= marketParams.tradingCutoff;\\n  }\\n\\n  ////////////////////////\\n  // Minimum Collateral //\\n  ////////////////////////\\n\\n  /// @notice Estimate minimum collateral required for given parameters\\n  /// @dev Position is liquidatable when position.collateral < minCollateral\\n  function _getMinCollateral(\\n    OptionType optionType,\\n    uint strikePrice,\\n    uint expiry,\\n    uint spotPrice,\\n    uint amount\\n  ) internal view returns (uint) {\\n    return\\n      greekCache.getMinCollateral(IOptionMarket.OptionType(uint(optionType)), strikePrice, expiry, spotPrice, amount);\\n  }\\n\\n  /// @notice Estimate minimum collateral required for an existing position\\n  function _getMinCollateralForPosition(uint positionId) internal view returns (uint) {\\n    IOptionToken.PositionWithOwner memory position = optionToken.getPositionWithOwner(positionId);\\n    if (_isLong(OptionType(uint(position.optionType)))) return 0;\\n\\n    uint strikePrice;\\n    uint expiry;\\n    (strikePrice, expiry) = optionMarket.getStrikeAndExpiry(position.strikeId);\\n\\n    return\\n      _getMinCollateral(\\n        OptionType(uint(position.optionType)),\\n        strikePrice,\\n        expiry,\\n        synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n        position.amount\\n      );\\n  }\\n\\n  /// @notice Estimate minimum collateral required for a given strike with manual amount\\n  function _getMinCollateralForStrike(\\n    OptionType optionType,\\n    uint strikeId,\\n    uint amount\\n  ) internal view returns (uint) {\\n    if (_isLong(optionType)) return 0;\\n\\n    uint strikePrice;\\n    uint expiry;\\n    (strikePrice, expiry) = optionMarket.getStrikeAndExpiry(strikeId);\\n\\n    return\\n      _getMinCollateral(\\n        optionType,\\n        strikePrice,\\n        expiry,\\n        synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n        amount\\n      );\\n  }\\n\\n  /////////////////\\n  // GWAV Oracle //\\n  /////////////////\\n\\n  /// @notice the `baseIv` GWAV for a given `boardId` with GWAV interval `secondsAgo`\\n  function _ivGWAV(uint boardId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.ivGWAV(boardId, secondsAgo);\\n  }\\n\\n  /// @notice the volatility `skew` GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _skewGWAV(uint strikeId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.skewGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the resultant volatility =`skew` * 'baseIv' for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _volGWAV(uint strikeId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.volGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the delta GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _deltaGWAV(uint strikeId, uint secondsAgo) internal view returns (int callDelta) {\\n    return gwavOracle.deltaGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the non-normalized vega GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _vegaGWAV(uint strikeId, uint secondsAgo) internal view returns (uint) {\\n    return gwavOracle.vegaGWAV(strikeId, secondsAgo);\\n  }\\n\\n  /// @notice the option price GWAV for a given `strikeId` with GWAV interval `secondsAgo`\\n  function _optionPriceGWAV(uint strikeId, uint secondsAgo) internal view returns (uint callPrice, uint putPrice) {\\n    return gwavOracle.optionPriceGWAV(strikeId, secondsAgo);\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  /// @dev format all strike related params before input into BlackScholes\\n  function _getBsInput(uint strikeId) internal view returns (BlackScholes.BlackScholesInputs memory bsInput) {\\n    (IOptionMarket.Strike memory strike, IOptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(\\n      strikeId\\n    );\\n    bsInput = BlackScholes.BlackScholesInputs({\\n      timeToExpirySec: board.expiry - block.timestamp,\\n      volatilityDecimal: board.iv.multiplyDecimal(strike.skew),\\n      spotDecimal: synthetixAdapter.getSpotPriceForMarket(address(optionMarket)),\\n      strikePriceDecimal: strike.strikePrice,\\n      rateDecimal: greekCache.getGreekCacheParams().rateAndCarry\\n    });\\n  }\\n\\n  /// @dev Check if position is long\\n  function _isLong(OptionType optionType) internal pure returns (bool) {\\n    return (optionType < OptionType.SHORT_CALL_BASE);\\n  }\\n\\n  /// @dev Convert LyraAdapter.TradeInputParameters into OptionMarket.TradeInputParameters\\n  function _convertParams(TradeInputParameters memory _params)\\n    internal\\n    pure\\n    returns (IOptionMarket.TradeInputParameters memory)\\n  {\\n    return\\n      IOptionMarket.TradeInputParameters({\\n        strikeId: _params.strikeId,\\n        positionId: _params.positionId,\\n        iterations: _params.iterations,\\n        optionType: IOptionMarket.OptionType(uint(_params.optionType)),\\n        amount: _params.amount,\\n        setCollateralTo: _params.setCollateralTo,\\n        minTotalCost: _params.minTotalCost,\\n        maxTotalCost: _params.maxTotalCost\\n      });\\n  }\\n\\n  /// @dev get lyra market addresses from LyraRegistry\\n  function _assignLyraRegistryMarketAddresses() internal {\\n    ILyraRegistry.OptionMarketAddresses memory addresses = lyraRegistry.getMarketAddresses(address(optionMarket));\\n\\n    liquidityPool = ILiquidityPool(addresses.liquidityPool);\\n    greekCache = IOptionGreekCache(addresses.greekCache);\\n    optionPricer = IOptionMarketPricer(addresses.optionMarketPricer);\\n    optionToken = IOptionToken(addresses.optionToken);\\n    shortCollateral = IShortCollateral(addresses.shortCollateral);\\n    gwavOracle = IGWAVOracle(addresses.gwavOracle);\\n    quoteAsset = addresses.quoteAsset;\\n    baseAsset = addresses.baseAsset;\\n  }\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n\\n  error ExchangerBaseReceivedTooLow(address thrower, uint baseExpected, uint baseReceived);\\n  error ExchangerQuoteReceivedTooLow(address thrower, uint quoteExpected, uint quoteReceived);\\n}\\n\",\"keccak256\":\"0xa39fc34236205de6593442ed73ea9bf5f2c7866a9ba6ebc41cc67add6681c31e\",\"license\":\"ISC\"},\"@lyrafinance/protocol/contracts/synthetix/AbstractOwned.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Owned\\n * @author Synthetix\\n * @dev Synthetix owned contract without constructor and custom errors\\n * @dev https://docs.synthetix.io/contracts/source/contracts/owned\\n */\\nabstract contract AbstractOwned {\\n  address public owner;\\n  address public nominatedOwner;\\n\\n  function nominateNewOwner(address _owner) external onlyOwner {\\n    nominatedOwner = _owner;\\n    emit OwnerNominated(_owner);\\n  }\\n\\n  function acceptOwnership() external {\\n    if (msg.sender != nominatedOwner) {\\n      revert OnlyNominatedOwner(address(this), msg.sender, nominatedOwner);\\n    }\\n    emit OwnerChanged(owner, nominatedOwner);\\n    owner = nominatedOwner;\\n    nominatedOwner = address(0);\\n  }\\n\\n  modifier onlyOwner() {\\n    _onlyOwner();\\n    _;\\n  }\\n\\n  function _onlyOwner() private view {\\n    if (msg.sender != owner) {\\n      revert OnlyOwner(address(this), msg.sender, owner);\\n    }\\n  }\\n\\n  event OwnerNominated(address newOwner);\\n  event OwnerChanged(address oldOwner, address newOwner);\\n\\n  ////////////\\n  // Errors //\\n  ////////////\\n  error OnlyOwner(address thrower, address caller, address owner);\\n  error OnlyNominatedOwner(address thrower, address caller, address nominatedOwner);\\n}\\n\",\"keccak256\":\"0x65a8b72ac2f352c2937de332355d7eb03efc7b6da78d42d3ae5d4fd6b0081ab6\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/synthetix/DecimalMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title DecimalMath\\n * @author Lyra\\n * @dev Modified synthetix SafeDecimalMath to include internal arithmetic underflow/overflow.\\n * @dev https://docs.synthetix.io/contracts/source/libraries/SafeDecimalMath/\\n */\\n\\nlibrary DecimalMath {\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  uint public constant UNIT = 10**uint(decimals);\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n  uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (uint) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (uint) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return (x * y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(\\n    uint x,\\n    uint y,\\n    uint precisionUnit\\n  ) private pure returns (uint) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    uint quotientTimesTen = (x * y) / (precisionUnit / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return (x * UNIT) / y;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(\\n    uint x,\\n    uint y,\\n    uint precisionUnit\\n  ) private pure returns (uint) {\\n    uint resultTimesTen = (x * (precisionUnit * 10)) / y;\\n\\n    if (resultTimesTen % 10 >= 5) {\\n      resultTimesTen += 10;\\n    }\\n\\n    return resultTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n    uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n}\\n\",\"keccak256\":\"0x03f58e91e4df7956ec2b2ae893fa20bf0784ea9e03afbf3f76e514175a3a90b2\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/synthetix/Owned.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./AbstractOwned.sol\\\";\\n\\n/**\\n * @title Owned\\n * @author Synthetix\\n * @dev Slightly modified Synthetix owned contract, so that first owner is msg.sender\\n * @dev https://docs.synthetix.io/contracts/source/contracts/owned\\n */\\ncontract Owned is AbstractOwned {\\n  constructor() {\\n    owner = msg.sender;\\n    emit OwnerChanged(address(0), msg.sender);\\n  }\\n}\\n\",\"keccak256\":\"0x6db7bcf05e088a9474773d2c1da20be364aac72cea20bbce4e54d4086de6719a\",\"license\":\"MIT\"},\"@lyrafinance/protocol/contracts/synthetix/SignedDecimalMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title SignedDecimalMath\\n * @author Lyra\\n * @dev Modified synthetix SafeSignedDecimalMath to include internal arithmetic underflow/overflow.\\n * @dev https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\n */\\nlibrary SignedDecimalMath {\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  int public constant UNIT = int(10**uint(decimals));\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  int public constant PRECISE_UNIT = int(10**uint(highPrecisionDecimals));\\n  int private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = int(10**uint(highPrecisionDecimals - decimals));\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (int) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (int) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @dev Rounds an input with an extra zero of precision, returning the result without the extra zero.\\n   * Half increments round away from zero; positive numbers at a half increment are rounded up,\\n   * while negative such numbers are rounded down. This behaviour is designed to be consistent with the\\n   * unsigned version of this library (SafeDecimalMath).\\n   */\\n  function _roundDividingByTen(int valueTimesTen) private pure returns (int) {\\n    int increment;\\n    if (valueTimesTen % 10 >= 5) {\\n      increment = 10;\\n    } else if (valueTimesTen % 10 <= -5) {\\n      increment = -10;\\n    }\\n    return (valueTimesTen + increment) / 10;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(int x, int y) internal pure returns (int) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return (x * y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(\\n    int x,\\n    int y,\\n    int precisionUnit\\n  ) private pure returns (int) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    int quotientTimesTen = (x * y) / (precisionUnit / 10);\\n    return _roundDividingByTen(quotientTimesTen);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(int x, int y) internal pure returns (int) {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(int x, int y) internal pure returns (int) {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(int x, int y) internal pure returns (int) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return (x * UNIT) / y;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(\\n    int x,\\n    int y,\\n    int precisionUnit\\n  ) private pure returns (int) {\\n    int resultTimesTen = (x * (precisionUnit * 10)) / y;\\n    return _roundDividingByTen(resultTimesTen);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(int x, int y) internal pure returns (int) {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(int x, int y) internal pure returns (int) {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(int i) internal pure returns (int) {\\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(int i) internal pure returns (int) {\\n    int quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n    return _roundDividingByTen(quotientTimesTen);\\n  }\\n}\\n\",\"keccak256\":\"0x7fac134730ad054cfa9f7a512bb3e54459fd9cf55f3cac1a3f0aefb5695a8cfc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x4823752b07b8ea4ca971b217e39457930e7cb103c2c91e2a29729e5ca907e4f0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xdadd41acb749920eccf40aeaa8d291adf9751399a7343561bad13e7a8d99be0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa2f576be637946f767aa56601c26d717f48a0aff44f82e46f13807eea1009a21\",\"license\":\"MIT\"},\"contracts/core/BaseVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\nimport {VaultLifecycle} from \\\"../libraries/VaultLifecycle.sol\\\";\\nimport {ShareMath} from \\\"../libraries/ShareMath.sol\\\";\\n\\ncontract BaseVault is ReentrancyGuard, Ownable, ERC20, Initializable {\\n  using SafeERC20 for IERC20;\\n  using ShareMath for Vault.DepositReceipt;\\n\\n  /************************************************\\n   *  NON UPGRADEABLE STORAGE\\n   ***********************************************/\\n\\n  /// @notice Stores the user's pending deposit for the round\\n  mapping(address => Vault.DepositReceipt) public depositReceipts;\\n\\n  /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\\n  /// This is used to determine the number of shares to be returned\\n  /// to a user with their DepositReceipt.depositAmount\\n  mapping(uint => uint) public roundPricePerShare;\\n\\n  /// @notice Stores pending user withdrawals\\n  mapping(address => Vault.Withdrawal) public withdrawals;\\n\\n  /// @notice Vault's parameters like cap, decimals\\n  Vault.VaultParams public vaultParams;\\n\\n  /// @notice Vault's lifecycle state like round and locked amounts\\n  Vault.VaultState public vaultState;\\n\\n  /// @notice Fee recipient for the performance and management fees\\n  address public feeRecipient;\\n\\n  /// @notice Performance fee charged on premiums earned in rollToNextOption. Only charged when there is no loss.\\n  uint public performanceFee;\\n\\n  /// @notice Management fee charged on entire AUM in rollToNextOption. Only charged when there is no loss.\\n  uint public managementFee;\\n\\n  // Gap is left to avoid storage collisions. Though RibbonVault is not upgradeable, we add this as a safety measure.\\n  uint[30] private ____gap;\\n\\n  // *IMPORTANT* NO NEW STORAGE VARIABLES SHOULD BE ADDED HERE\\n  // This is to prevent storage collisions. All storage variables should be appended to RibbonThetaVaultStorage\\n  // or RibbonDeltaVaultStorage instead. Read this documentation to learn more:\\n  // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts\\n\\n  /************************************************\\n   *  IMMUTABLES & CONSTANTS\\n   ***********************************************/\\n\\n  // Round per year scaled up FEE_MULTIPLIER\\n  uint private immutable roundPerYear;\\n\\n  /************************************************\\n   *  EVENTS\\n   ***********************************************/\\n\\n  event Deposit(address indexed account, uint amount, uint round);\\n\\n  event InitiateWithdraw(address indexed account, uint shares, uint round);\\n\\n  event Redeem(address indexed account, uint share, uint round);\\n\\n  event ManagementFeeSet(uint managementFee, uint newManagementFee);\\n\\n  event PerformanceFeeSet(uint performanceFee, uint newPerformanceFee);\\n\\n  event CapSet(uint oldCap, uint newCap, address manager);\\n\\n  event Withdraw(address indexed account, uint amount, uint shares);\\n\\n  event CollectVaultFees(uint performanceFee, uint vaultFee, uint round, address indexed feeRecipient);\\n\\n  /************************************************\\n   *  CONSTRUCTOR & INITIALIZATION\\n   ***********************************************/\\n\\n  /**\\n   * @notice Initializes the contract with immutable variables\\n   */\\n  constructor(\\n    address _feeRecipient,\\n    uint _roundDuration,\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    Vault.VaultParams memory _vaultParams\\n  ) ERC20(_tokenName, _tokenSymbol) {\\n    feeRecipient = _feeRecipient;\\n    uint _roundPerYear = (uint(365 days) * Vault.FEE_MULTIPLIER) / _roundDuration;\\n    roundPerYear = _roundPerYear;\\n    vaultParams = _vaultParams;\\n\\n    uint assetBalance = IERC20(vaultParams.asset).balanceOf(address(this));\\n    ShareMath.assertUint104(assetBalance);\\n    vaultState.lastLockedAmount = uint104(assetBalance);\\n    vaultState.round = 1;\\n  }\\n\\n  /************************************************\\n   *  SETTERS\\n   ***********************************************/\\n\\n  /**\\n   * @notice Sets the new fee recipient\\n   * @param newFeeRecipient is the address of the new fee recipient\\n   */\\n  function setFeeRecipient(address newFeeRecipient) external onlyOwner {\\n    require(newFeeRecipient != address(0), \\\"!newFeeRecipient\\\");\\n    require(newFeeRecipient != feeRecipient, \\\"Must be new feeRecipient\\\");\\n    feeRecipient = newFeeRecipient;\\n  }\\n\\n  /**\\n   * @notice Sets the management fee for the vault\\n   * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\\n   */\\n  function setManagementFee(uint newManagementFee) external onlyOwner {\\n    require(newManagementFee < 100 * Vault.FEE_MULTIPLIER, \\\"Invalid management fee\\\");\\n\\n    emit ManagementFeeSet(managementFee, newManagementFee);\\n\\n    // We are dividing annualized management fee by number of rounds in a year\\n    managementFee = (newManagementFee * Vault.FEE_MULTIPLIER) / roundPerYear;\\n  }\\n\\n  /**\\n   * @notice Sets the performance fee for the vault\\n   * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\\n   */\\n  function setPerformanceFee(uint newPerformanceFee) external onlyOwner {\\n    require(newPerformanceFee < 100 * Vault.FEE_MULTIPLIER, \\\"Invalid performance fee\\\");\\n\\n    emit PerformanceFeeSet(performanceFee, newPerformanceFee);\\n\\n    performanceFee = newPerformanceFee;\\n  }\\n\\n  /**\\n   * @notice Sets a new cap for deposits\\n   * @param newCap is the new cap for deposits\\n   */\\n  function setCap(uint newCap) external onlyOwner {\\n    require(newCap > 0, \\\"!newCap\\\");\\n\\n    emit CapSet(vaultParams.cap, newCap, msg.sender);\\n\\n    ShareMath.assertUint104(newCap);\\n    vaultParams.cap = uint104(newCap);\\n  }\\n\\n  /************************************************\\n   *  DEPOSIT & WITHDRAWALS\\n   ***********************************************/\\n\\n  /**\\n   * @notice Deposits the `asset` from msg.sender.\\n   * @param amount is the amount of `asset` to deposit\\n   */\\n  function deposit(uint amount) external nonReentrant {\\n    require(amount > 0, \\\"!amount\\\");\\n\\n    _depositFor(amount, msg.sender);\\n\\n    // An approve() by the msg.sender is required beforehand\\n    IERC20(vaultParams.asset).safeTransferFrom(msg.sender, address(this), amount);\\n  }\\n\\n  /**\\n   * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\\n   * @notice Used for vault -> vault deposits on the user's behalf\\n   * @param amount is the amount of `asset` to deposit\\n   * @param creditor is the address that can claim/withdraw deposited amount\\n   */\\n  function depositFor(uint amount, address creditor) external nonReentrant {\\n    require(amount > 0, \\\"!amount\\\");\\n    require(creditor != address(0), \\\"!creditor\\\");\\n\\n    _depositFor(amount, creditor);\\n\\n    // An approve() by the msg.sender is required beforehand\\n    IERC20(vaultParams.asset).safeTransferFrom(msg.sender, address(this), amount);\\n  }\\n\\n  /**\\n   * @notice Mints the vault shares to the creditor\\n   * @param amount is the amount of `asset` deposited\\n   * @param creditor is the address to receieve the deposit\\n   */\\n  function _depositFor(uint amount, address creditor) private {\\n    uint currentRound = vaultState.round;\\n    uint totalWithDepositedAmount = totalBalance() + amount;\\n\\n    require(totalWithDepositedAmount <= vaultParams.cap, \\\"Exceed cap\\\");\\n\\n    emit Deposit(creditor, amount, currentRound);\\n\\n    Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\\n\\n    // process unprocessed pending deposit from the previous rounds\\n    uint unredeemedShares = depositReceipt.getSharesFromReceipt(\\n      currentRound,\\n      roundPricePerShare[depositReceipt.round],\\n      vaultParams.decimals\\n    );\\n\\n    uint depositAmount = amount;\\n\\n    // If we have a pending deposit in the current round, we add on to the pending deposit\\n    if (currentRound == depositReceipt.round) {\\n      uint newAmount = uint(depositReceipt.amount) + amount;\\n      depositAmount = newAmount;\\n    }\\n\\n    ShareMath.assertUint104(depositAmount);\\n\\n    depositReceipts[creditor] = Vault.DepositReceipt({\\n      round: uint16(currentRound),\\n      amount: uint104(depositAmount),\\n      unredeemedShares: uint128(unredeemedShares)\\n    });\\n\\n    uint newTotalPending = uint(vaultState.totalPending) + amount;\\n    ShareMath.assertUint128(newTotalPending);\\n\\n    vaultState.totalPending = uint128(newTotalPending);\\n  }\\n\\n  /**\\n   * @notice Initiates a withdrawal that can be processed once the round completes\\n   * @param numShares is the number of shares to withdraw\\n   */\\n  function initiateWithdraw(uint numShares) external nonReentrant {\\n    require(numShares > 0, \\\"!numShares\\\");\\n\\n    // We do a max redeem before initiating a withdrawal\\n    // But we check if they must first have unredeemed shares\\n    if (depositReceipts[msg.sender].amount > 0 || depositReceipts[msg.sender].unredeemedShares > 0) {\\n      _redeem(0, true);\\n    }\\n\\n    // This caches the `round` variable used in shareBalances\\n    uint currentRound = vaultState.round;\\n    Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\\n\\n    bool withdrawalIsSameRound = withdrawal.round == currentRound;\\n\\n    emit InitiateWithdraw(msg.sender, numShares, currentRound);\\n\\n    uint existingShares = uint(withdrawal.shares);\\n\\n    uint withdrawalShares;\\n    if (withdrawalIsSameRound) {\\n      withdrawalShares = existingShares + numShares;\\n    } else {\\n      require(existingShares == 0, \\\"Existing withdraw\\\");\\n      withdrawalShares = numShares;\\n      withdrawals[msg.sender].round = uint16(currentRound);\\n    }\\n\\n    ShareMath.assertUint128(withdrawalShares);\\n    withdrawals[msg.sender].shares = uint128(withdrawalShares);\\n\\n    uint newQueuedWithdrawShares = uint(vaultState.queuedWithdrawShares) + numShares;\\n    ShareMath.assertUint128(newQueuedWithdrawShares);\\n    vaultState.queuedWithdrawShares = uint128(newQueuedWithdrawShares);\\n\\n    _transfer(msg.sender, address(this), numShares);\\n  }\\n\\n  /**\\n   * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\\n   */\\n  function completeWithdraw() external nonReentrant {\\n    Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\\n\\n    uint withdrawalShares = withdrawal.shares;\\n    uint withdrawalRound = withdrawal.round;\\n\\n    // This checks if there is a withdrawal\\n    require(withdrawalShares > 0, \\\"Not initiated\\\");\\n\\n    require(withdrawalRound < vaultState.round, \\\"Round in progress\\\");\\n\\n    // We leave the round number as non-zero to save on gas for subsequent writes\\n    withdrawals[msg.sender].shares = 0;\\n    vaultState.queuedWithdrawShares = uint128(uint(vaultState.queuedWithdrawShares) - withdrawalShares);\\n\\n    uint withdrawAmount = ShareMath.sharesToAsset(\\n      withdrawalShares,\\n      roundPricePerShare[withdrawalRound],\\n      vaultParams.decimals\\n    );\\n\\n    emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\\n\\n    _burn(address(this), withdrawalShares);\\n\\n    require(withdrawAmount > 0, \\\"!withdrawAmount\\\");\\n\\n    _transferAsset(msg.sender, withdrawAmount);\\n  }\\n\\n  /**\\n   * @notice Redeems shares that are owed to the account\\n   * @param numShares is the number of shares to redeem\\n   */\\n  function redeem(uint numShares) external nonReentrant {\\n    require(numShares > 0, \\\"!numShares\\\");\\n    _redeem(numShares, false);\\n  }\\n\\n  /**\\n   * @notice Redeems the entire unredeemedShares balance that is owed to the account\\n   */\\n  function maxRedeem() external nonReentrant {\\n    _redeem(0, true);\\n  }\\n\\n  /**\\n   * @notice Redeems shares that are owed to the account\\n   * @param numShares is the number of shares to redeem, could be 0 when isMax=true\\n   * @param isMax is flag for when callers do a max redemption\\n   */\\n  function _redeem(uint numShares, bool isMax) internal {\\n    Vault.DepositReceipt memory depositReceipt = depositReceipts[msg.sender];\\n\\n    // This handles the null case when depositReceipt.round = 0\\n    // Because we start with round = 1 at `initialize`\\n    uint currentRound = vaultState.round;\\n\\n    uint unredeemedShares = depositReceipt.getSharesFromReceipt(\\n      currentRound,\\n      roundPricePerShare[depositReceipt.round],\\n      vaultParams.decimals\\n    );\\n\\n    numShares = isMax ? unredeemedShares : numShares;\\n    if (numShares == 0) {\\n      return;\\n    }\\n    require(numShares <= unredeemedShares, \\\"Exceeds available\\\");\\n\\n    // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\\n    // we debit from the unredeemedShares, but leave the amount field intact\\n    // If the round has past, with no new deposits, we just zero it out for new deposits.\\n    depositReceipts[msg.sender].amount = depositReceipt.round < currentRound ? 0 : depositReceipt.amount;\\n\\n    ShareMath.assertUint128(numShares);\\n    depositReceipts[msg.sender].unredeemedShares = uint128(unredeemedShares - numShares);\\n\\n    emit Redeem(msg.sender, numShares, depositReceipt.round);\\n\\n    _transfer(address(this), msg.sender, numShares);\\n  }\\n\\n  /************************************************\\n   *  VAULT OPERATIONS\\n   ***********************************************/\\n\\n  /*\\n   * @notice Helper function that performs most administrative tasks\\n   * such as setting next option, minting new shares, getting vault fees, etc.\\n   * @param lastQueuedWithdrawAmount is old queued withdraw amount\\n   * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\\n   * @return queuedWithdrawAmount is the new queued withdraw amount for this round\\n   */\\n  function _rollToNextRound(uint lastQueuedWithdrawAmount) internal returns (uint, uint) {\\n    (uint lockedBalance, uint queuedWithdrawAmount, uint newPricePerShare, uint mintShares) = VaultLifecycle.rollover(\\n      totalSupply(),\\n      vaultParams.asset,\\n      vaultParams.decimals,\\n      uint(vaultState.totalPending),\\n      vaultState.queuedWithdrawShares\\n    );\\n\\n    // Finalize the pricePerShare at the end of the round\\n    uint currentRound = vaultState.round;\\n    roundPricePerShare[currentRound] = newPricePerShare;\\n\\n    uint withdrawAmountDiff = queuedWithdrawAmount > lastQueuedWithdrawAmount\\n      ? queuedWithdrawAmount - lastQueuedWithdrawAmount\\n      : 0;\\n\\n    // Take management / performance fee from previous round and deduct\\n    lockedBalance = lockedBalance - _collectVaultFees(lockedBalance + withdrawAmountDiff);\\n\\n    // update round info\\n    vaultState.totalPending = 0;\\n    vaultState.round = uint16(currentRound + 1);\\n\\n    _mint(address(this), mintShares);\\n\\n    return (lockedBalance, queuedWithdrawAmount);\\n  }\\n\\n  /*\\n   * @notice Helper function that transfers management fees and performance fees from previous round.\\n   * @param pastWeekBalance is the balance we are about to lock for next round\\n   * @return vaultFee is the fee deducted\\n   */\\n  function _collectVaultFees(uint pastWeekBalance) internal returns (uint) {\\n    (uint performanceFeeInAsset, , uint vaultFee) = VaultLifecycle.getVaultFees(\\n      vaultState,\\n      pastWeekBalance,\\n      performanceFee,\\n      managementFee\\n    );\\n\\n    if (vaultFee > 0) {\\n      _transferAsset(payable(feeRecipient), vaultFee);\\n      emit CollectVaultFees(performanceFeeInAsset, vaultFee, vaultState.round, feeRecipient);\\n    }\\n\\n    return vaultFee;\\n  }\\n\\n  /**\\n   * @notice Helper function to make either an ETH transfer or ERC20 transfer\\n   * @param recipient is the receiving address\\n   * @param amount is the transfer amount\\n   */\\n  function _transferAsset(address recipient, uint amount) internal {\\n    address asset = vaultParams.asset;\\n    IERC20(asset).safeTransfer(recipient, amount);\\n  }\\n\\n  /************************************************\\n   *  GETTERS\\n   ***********************************************/\\n\\n  /**\\n   * @notice Returns the asset balance held on the vault for the account\\n   * @param account is the address to lookup balance for\\n   * @return the amount of `asset` custodied by the vault for the user\\n   */\\n  function accountVaultBalance(address account) external view returns (uint) {\\n    uint _decimals = vaultParams.decimals;\\n    uint assetPerShare = ShareMath.pricePerShare(totalSupply(), totalBalance(), vaultState.totalPending, _decimals);\\n    return ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\\n  }\\n\\n  /**\\n   * @notice Getter for returning the account's share balance including unredeemed shares\\n   * @param account is the account to lookup share balance for\\n   * @return the share balance\\n   */\\n  function shares(address account) public view returns (uint) {\\n    (uint heldByAccount, uint heldByVault) = shareBalances(account);\\n    return heldByAccount + heldByVault;\\n  }\\n\\n  /**\\n   * @notice Getter for returning the account's share balance split between account and vault holdings\\n   * @param account is the account to lookup share balance for\\n   * @return heldByAccount is the shares held by account\\n   * @return heldByVault is the shares held on the vault (unredeemedShares)\\n   */\\n  function shareBalances(address account) public view returns (uint heldByAccount, uint heldByVault) {\\n    Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\\n\\n    if (depositReceipt.round == 0) {\\n      return (balanceOf(account), 0);\\n    }\\n\\n    uint unredeemedShares = depositReceipt.getSharesFromReceipt(\\n      vaultState.round,\\n      roundPricePerShare[depositReceipt.round],\\n      vaultParams.decimals\\n    );\\n\\n    return (balanceOf(account), unredeemedShares);\\n  }\\n\\n  /**\\n   * @notice The price of a unit of share denominated in the `asset`\\n   */\\n  function pricePerShare() external view returns (uint) {\\n    return ShareMath.pricePerShare(totalSupply(), totalBalance(), vaultState.totalPending, vaultParams.decimals);\\n  }\\n\\n  /**\\n   * @notice Returns the vault's total balance, including the amounts locked into a short position\\n   * @return total balance of the vault, including the amounts locked in third party protocols\\n   */\\n  function totalBalance() public view returns (uint) {\\n    return\\n      uint(vaultState.lockedAmount - vaultState.lockedAmountLeft) + IERC20(vaultParams.asset).balanceOf(address(this));\\n  }\\n\\n  /**\\n   * @notice Returns the token decimals\\n   */\\n  function decimals() public view override returns (uint8) {\\n    return vaultParams.decimals;\\n  }\\n}\\n\",\"keccak256\":\"0x161bb74ce2ab4b7d7fc490678875f527b92eca9fbb9fc0a8e66c91d8ea674e0f\",\"license\":\"MIT\"},\"contracts/core/LyraVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {BaseVault} from \\\"./BaseVault.sol\\\";\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\n\\nimport {IStrategy} from \\\"../interfaces/IStrategy.sol\\\";\\n\\n/// @notice LyraVault help users run option-selling strategies on Lyra AMM.\\ncontract LyraVault is Ownable, BaseVault {\\n  IERC20 public immutable premiumAsset;\\n  IERC20 public immutable collateralAsset;\\n\\n  IStrategy public strategy;\\n  address public lyraRewardRecipient;\\n\\n  // Amount locked for scheduled withdrawals last week;\\n  uint public lastQueuedWithdrawAmount;\\n  // % of funds to be used for weekly option purchase\\n  uint public optionAllocation;\\n\\n  event StrategyUpdated(address strategy);\\n\\n  event Trade(address user, uint positionId, uint premium, uint capitalUsed);\\n\\n  event RoundStarted(uint16 roundId, uint104 lockAmount);\\n\\n  event RoundClosed(uint16 roundId, uint104 lockAmount);\\n\\n  constructor(\\n    address _susd,\\n    address _feeRecipient,\\n    uint _roundDuration,\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    Vault.VaultParams memory _vaultParams\\n  ) BaseVault(_feeRecipient, _roundDuration, _tokenName, _tokenSymbol, _vaultParams) {\\n    premiumAsset = IERC20(_susd);\\n    collateralAsset = IERC20(_vaultParams.asset);\\n  }\\n\\n  /// @dev set strategy contract. This function can only be called by owner.\\n  /// @param _strategy new strategy contract address\\n  function setStrategy(address _strategy) external onlyOwner {\\n    if (address(strategy) != address(0)) {\\n      collateralAsset.approve(address(strategy), 0);\\n    }\\n\\n    strategy = IStrategy(_strategy);\\n    collateralAsset.approve(_strategy, type(uint).max);\\n    emit StrategyUpdated(_strategy);\\n  }\\n\\n  /// @dev anyone can trigger a trade\\n  /// @param strikeId the strike id to sell\\n  function trade(uint strikeId) external {\\n    require(vaultState.roundInProgress, \\\"round closed\\\");\\n    // perform trade through strategy\\n    (uint positionId, uint premiumReceived, uint capitalUsed) = strategy.doTrade(strikeId, lyraRewardRecipient);\\n\\n    // update the remaining locked amount\\n    vaultState.lockedAmountLeft = vaultState.lockedAmountLeft - capitalUsed;\\n\\n    // todo: udpate events\\n    emit Trade(msg.sender, positionId, premiumReceived, capitalUsed);\\n  }\\n\\n  /// @dev anyone close part of the position with premium made by the strategy if a position is dangerous\\n  /// @param positionId the positiion to close\\n  function reducePosition(uint positionId, uint closeAmount) external {\\n    strategy.reducePosition(positionId, closeAmount, lyraRewardRecipient);\\n  }\\n\\n  /// @dev close the current round, enable user to deposit for the next round\\n  function closeRound() external {\\n    require(strategy.activeExpiry() < block.timestamp, \\\"cannot close round if board not expired\\\");\\n    require(vaultState.roundInProgress, \\\"round closed\\\");\\n\\n    uint104 lockAmount = vaultState.lockedAmount;\\n    vaultState.lastLockedAmount = lockAmount;\\n    vaultState.lockedAmountLeft = 0;\\n    vaultState.lockedAmount = 0;\\n    vaultState.nextRoundReadyTimestamp = block.timestamp + Vault.ROUND_DELAY;\\n    vaultState.roundInProgress = false;\\n\\n    // won't be able to close if positions are not settled\\n    strategy.returnFundsAndClearStrikes();\\n\\n    emit RoundClosed(vaultState.round, lockAmount);\\n  }\\n\\n  /// @dev Close the current round, enable user to deposit for the next round\\n  //       Can call multiple times before round starts to close all positions\\n  function emergencyCloseRound() external onlyOwner {\\n    require(vaultState.roundInProgress, \\\"round closed\\\");\\n\\n    uint104 lockAmount = vaultState.lockedAmount;\\n    vaultState.lastLockedAmount = lockAmount;\\n    vaultState.lockedAmountLeft = 0;\\n    vaultState.lockedAmount = 0;\\n    vaultState.nextRoundReadyTimestamp = block.timestamp + Vault.ROUND_DELAY;\\n    vaultState.roundInProgress = false;\\n\\n    strategy.emergencyCloseAll(lyraRewardRecipient);\\n    emit RoundClosed(vaultState.round, lockAmount);\\n  }\\n\\n  /// @notice start the next round\\n  /// @param boardId board id (asset + expiry) for next round.\\n  function startNextRound(uint boardId) external onlyOwner {\\n    require(!vaultState.roundInProgress, \\\"round in progress\\\");\\n    require(block.timestamp > vaultState.nextRoundReadyTimestamp, \\\"Delay between rounds not elapsed\\\");\\n\\n    strategy.setBoard(boardId);\\n\\n    (uint lockedBalance, uint queuedWithdrawAmount) = _rollToNextRound(lastQueuedWithdrawAmount);\\n\\n    vaultState.lockedAmount = uint104(lockedBalance);\\n    vaultState.lockedAmountLeft = lockedBalance;\\n    vaultState.roundInProgress = true;\\n    lastQueuedWithdrawAmount = queuedWithdrawAmount;\\n\\n    emit RoundStarted(vaultState.round, uint104(lockedBalance));\\n  }\\n\\n  /// @notice set set new address to receive Lyra trading reward on behalf of the vault\\n  /// @param recipient recipient address\\n  function setLyraRewardRecipient(address recipient) external onlyOwner {\\n    lyraRewardRecipient = recipient;\\n  }\\n}\\n\",\"keccak256\":\"0xa10a9a953dd3c57e6e6657027d7d81d4c2c221c2cdb3c409d0a3b2db139d26a5\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Detailed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20Detailed is IERC20 {\\n  function decimals() external view returns (uint8);\\n\\n  function symbol() external view returns (string calldata);\\n\\n  function name() external view returns (string calldata);\\n}\\n\",\"keccak256\":\"0x98fdc868b087fd38e413b31c1687bb9a3ed756d975795e259ba066ff4a1ac3b8\",\"license\":\"MIT\"},\"contracts/interfaces/IStrategy.sol\":{\"content\":\"//SPDX-License-Identifier:MIT\\npragma solidity ^0.8.9;\\n\\ninterface IStrategy {\\n  function activeExpiry() external returns (uint);\\n\\n  function setBoard(uint boardId) external;\\n\\n  function doTrade(uint strikeId, address rewardRecipient)\\n    external\\n    returns (\\n      uint positionId,\\n      uint premium,\\n      uint collateralAdded\\n    );\\n\\n  function reducePosition(\\n    uint positionId,\\n    uint closeAmount,\\n    address rewardRecipient\\n  ) external;\\n\\n  function emergencyCloseAll(address lyraRewardRecipient) external;\\n\\n  function returnFundsAndClearStrikes() external;\\n}\\n\",\"keccak256\":\"0x924ce8d0f4b7047484cb610d6016f39ce953dc898ec68cf1f1cf3aef78c19925\",\"license\":\"MIT\"},\"contracts/libraries/ShareMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {Vault} from \\\"./Vault.sol\\\";\\n\\nlibrary ShareMath {\\n  function assetToShares(\\n    uint assetAmount,\\n    uint assetPerShare,\\n    uint decimals\\n  ) internal pure returns (uint) {\\n    // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\\n    // which should never happen.\\n    require(assetPerShare > 0, \\\"Invalid assetPerShare\\\");\\n\\n    return (assetAmount * (10**decimals)) / (assetPerShare);\\n  }\\n\\n  function sharesToAsset(\\n    uint shares,\\n    uint assetPerShare,\\n    uint decimals\\n  ) internal pure returns (uint) {\\n    // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\\n    // which should never happen.\\n    require(assetPerShare > 0, \\\"Invalid assetPerShare\\\");\\n\\n    return (shares * assetPerShare) / (10**decimals);\\n  }\\n\\n  /**\\n   * @notice Returns the shares unredeemed by the user given their DepositReceipt\\n   * @param depositReceipt is the user's deposit receipt\\n   * @param currentRound is the `round` stored on the vault\\n   * @param assetPerShare is the price in asset per share\\n   * @param decimals is the number of decimals the asset/shares use\\n   * @return unredeemedShares is the user's virtual balance of shares that are owed\\n   */\\n  function getSharesFromReceipt(\\n    Vault.DepositReceipt memory depositReceipt,\\n    uint currentRound,\\n    uint assetPerShare,\\n    uint decimals\\n  ) internal pure returns (uint unredeemedShares) {\\n    if (depositReceipt.round > 0 && depositReceipt.round < currentRound) {\\n      uint sharesFromRound = assetToShares(depositReceipt.amount, assetPerShare, decimals);\\n\\n      return uint(depositReceipt.unredeemedShares) + sharesFromRound;\\n    }\\n    return depositReceipt.unredeemedShares;\\n  }\\n\\n  function pricePerShare(\\n    uint totalSupply,\\n    uint totalBalance,\\n    uint pendingAmount,\\n    uint decimals\\n  ) internal pure returns (uint) {\\n    uint singleShare = 10**decimals;\\n    return totalSupply > 0 ? (singleShare * (totalBalance - pendingAmount)) / (totalSupply) : singleShare;\\n  }\\n\\n  /************************************************\\n   *  HELPERS\\n   ***********************************************/\\n\\n  function assertUint104(uint num) internal pure {\\n    require(num <= type(uint104).max, \\\"Overflow uint104\\\");\\n  }\\n\\n  function assertUint128(uint num) internal pure {\\n    require(num <= type(uint128).max, \\\"Overflow uint128\\\");\\n  }\\n}\\n\",\"keccak256\":\"0xa4bc80db31e67f2b3695c1e0ff2130b71ba7b5ab45cf760a0574a12a079a6b70\",\"license\":\"MIT\"},\"contracts/libraries/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nlibrary Vault {\\n  /************************************************\\n   *  IMMUTABLES & CONSTANTS\\n   ***********************************************/\\n\\n  // Fees are 6-decimal places. For example: 20 * 10**6 = 20%\\n  uint internal constant FEE_MULTIPLIER = 10**6;\\n\\n  uint internal constant ROUND_DELAY = 1 days;\\n\\n  struct VaultParams {\\n    // Token decimals for vault shares\\n    uint8 decimals;\\n    // Vault cap\\n    uint104 cap;\\n    // Asset used in Theta / Delta Vault\\n    address asset;\\n  }\\n\\n  struct VaultState {\\n    // 32 byte slot 1\\n    //  Current round number. `round` represents the number of `period`s elapsed.\\n    uint16 round;\\n    // Amount that is currently locked for the strategy\\n    uint104 lockedAmount;\\n    // Amount that was locked for strategy in the previous round\\n    // used for calculating performance fee deduction\\n    uint104 lastLockedAmount;\\n    // locked amount left to be used for collateral;\\n    uint lockedAmountLeft;\\n    // 32 byte slot 2\\n    // Stores the total tally of how much of `asset` there is\\n    // to be used to mint rTHETA tokens\\n    uint128 totalPending;\\n    // Amount locked for scheduled withdrawals;\\n    uint128 queuedWithdrawShares;\\n    // The timestamp next round will be ready to start\\n    uint nextRoundReadyTimestamp;\\n    // true if the current round is in progress, false if the round is idle\\n    bool roundInProgress;\\n  }\\n\\n  struct DepositReceipt {\\n    // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n    uint16 round;\\n    // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\\n    uint104 amount;\\n    // Unredeemed shares balance\\n    uint128 unredeemedShares;\\n  }\\n\\n  struct Withdrawal {\\n    // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n    uint16 round;\\n    // Number of shares withdrawn\\n    uint128 shares;\\n  }\\n}\\n\",\"keccak256\":\"0x8da4207bd6804b6d00e2dc8913218297a725525c55138afdf5ee7c41404516e1\",\"license\":\"MIT\"},\"contracts/libraries/VaultLifecycle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Vault} from \\\"./Vault.sol\\\";\\nimport {ShareMath} from \\\"./ShareMath.sol\\\";\\n\\nimport {IERC20Detailed} from \\\"../interfaces/IERC20Detailed.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @dev copied from Ribbon's VaultLifeCycle, changed to internal library for gas optimization\\n */\\nlibrary VaultLifecycle {\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  /**\\n   * @notice Calculate the shares to mint, new price per share,\\n   *         and amount of funds to re-allocate as collateral for the new round\\n   * @param currentShareSupply is the total supply of shares\\n   * @param asset is the address of the vault's asset\\n   * @param decimals is the decimals of the asset\\n   * @param pendingAmount is the amount of funds pending from recent deposits\\n   * @return newLockedAmount is the amount of funds to allocate for the new round\\n   * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\\n   * @return newPricePerShare is the price per share of the new round\\n   * @return mintShares is the amount of shares to mint from deposits\\n   */\\n  function rollover(\\n    uint currentShareSupply,\\n    address asset,\\n    uint decimals,\\n    uint pendingAmount,\\n    uint queuedWithdrawShares\\n  )\\n    internal\\n    view\\n    returns (\\n      uint newLockedAmount,\\n      uint queuedWithdrawAmount,\\n      uint newPricePerShare,\\n      uint mintShares\\n    )\\n  {\\n    uint currentBalance = IERC20(asset).balanceOf(address(this));\\n\\n    newPricePerShare = ShareMath.pricePerShare(currentShareSupply, currentBalance, pendingAmount, decimals);\\n\\n    // After closing the short, if the options expire in-the-money\\n    // vault pricePerShare would go down because vault's asset balance decreased.\\n    // This ensures that the newly-minted shares do not take on the loss.\\n    uint _mintShares = ShareMath.assetToShares(pendingAmount, newPricePerShare, decimals);\\n\\n    uint newSupply = currentShareSupply.add(_mintShares);\\n\\n    uint queuedWithdraw = newSupply > 0 ? ShareMath.sharesToAsset(queuedWithdrawShares, newPricePerShare, decimals) : 0;\\n\\n    return (currentBalance.sub(queuedWithdraw), queuedWithdraw, newPricePerShare, _mintShares);\\n  }\\n\\n  /**\\n   * @notice Calculates the performance and management fee for this week's round\\n   * @param vaultState is the struct with vault accounting state\\n   * @param currentLockedBalance is the amount of funds currently locked in opyn\\n   * @param performanceFeePercent is the performance fee pct.\\n   * @param managementFeePercent is the management fee pct.\\n   * @return performanceFeeInAsset is the performance fee\\n   * @return managementFeeInAsset is the management fee\\n   * @return vaultFee is the total fees\\n   */\\n  function getVaultFees(\\n    Vault.VaultState storage vaultState,\\n    uint currentLockedBalance,\\n    uint performanceFeePercent,\\n    uint managementFeePercent\\n  )\\n    internal\\n    view\\n    returns (\\n      uint performanceFeeInAsset,\\n      uint managementFeeInAsset,\\n      uint vaultFee\\n    )\\n  {\\n    uint prevLockedAmount = vaultState.lastLockedAmount;\\n\\n    uint lockedBalanceSansPending = currentLockedBalance.sub(vaultState.totalPending);\\n\\n    uint _performanceFeeInAsset;\\n    uint _managementFeeInAsset;\\n    uint _vaultFee;\\n\\n    // Take performance fee and management fee ONLY if difference between\\n    // last week and this week's vault deposits, taking into account pending\\n    // deposits and withdrawals, is positive. If it is negative, last week's\\n    // option expired ITM past breakeven, and the vault took a loss so we\\n    // do not collect performance fee for last week\\n\\n    // todo: update management fee to exclude profit?\\n    if (lockedBalanceSansPending > prevLockedAmount) {\\n      _performanceFeeInAsset = performanceFeePercent > 0\\n        ? lockedBalanceSansPending.sub(prevLockedAmount).mul(performanceFeePercent).div(100 * Vault.FEE_MULTIPLIER)\\n        : 0;\\n      _managementFeeInAsset = managementFeePercent > 0\\n        ? lockedBalanceSansPending.mul(managementFeePercent).div(100 * Vault.FEE_MULTIPLIER)\\n        : 0;\\n\\n      _vaultFee = _performanceFeeInAsset.add(_managementFeeInAsset);\\n    }\\n\\n    return (_performanceFeeInAsset, _managementFeeInAsset, _vaultFee);\\n  }\\n}\\n\",\"keccak256\":\"0xbd4eee6e00d874390b27d2be4e7e796c33bd7dae1fb264ea5856c677726f0291\",\"license\":\"MIT\"},\"contracts/strategies/DeltaShortStrategy.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// standard strategy interface\\nimport \\\"../interfaces/IStrategy.sol\\\";\\n\\n// Libraries\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {LyraVault} from \\\"../core/LyraVault.sol\\\";\\nimport {DecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/DecimalMath.sol\\\";\\nimport {SignedDecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/SignedDecimalMath.sol\\\";\\n\\n// StrategyBase to inherit\\nimport {StrategyBase} from \\\"./StrategyBase.sol\\\";\\n\\ncontract DeltaShortStrategy is StrategyBase, IStrategy {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  // example strategy detail\\n  struct DeltaShortStrategyDetail {\\n    uint minTimeToExpiry; // minimum board expiry\\n    uint maxTimeToExpiry; // maximum board expiry\\n    int targetDelta; // ideal option delta to trade\\n    uint maxDeltaGap; // max diff between targetDelta and option delta\\n    uint minVol; // min option volatility required\\n    uint maxVol; // max option volatility required\\n    uint size; // amount of options to sell per LyraVault.trade()\\n    uint minTradeInterval; // min seconds between LyraVault.trade() calls\\n    uint maxVolVariance; // max deviation from GWAV vol and option volatility\\n    uint gwavPeriod; // gwav period used when calculating GWAV vol\\n    uint collatBuffer; // multiple of vaultAdapter.minCollateral(): 1.1 -> 110% * minCollat\\n    uint collatPercent; // partial collateral: 0.9 -> 90% * fullCollat\\n  }\\n\\n  DeltaShortStrategyDetail public strategyDetail;\\n  uint public activeExpiry;\\n\\n  ///////////\\n  // ADMIN //\\n  ///////////\\n\\n  constructor(LyraVault _vault, OptionType _optionType) StrategyBase(_vault, _optionType) {}\\n\\n  /**\\n   * @dev update the strategy detail for the new round.\\n   */\\n  function setStrategyDetail(DeltaShortStrategyDetail memory _deltaStrategy) external onlyOwner {\\n    (, , , , , , , bool roundInProgress) = vault.vaultState();\\n    require(!roundInProgress, \\\"cannot change strategy if round is active\\\");\\n    strategyDetail = _deltaStrategy;\\n  }\\n\\n  /**\\n   * @dev set the board id that will be traded for the next round\\n   * @param boardId lyra board Id.\\n   */\\n  function setBoard(uint boardId) external onlyVault {\\n    Board memory board = _getBoard(boardId);\\n    require(_isValidExpiry(board.expiry), \\\"invalid board\\\");\\n    activeExpiry = board.expiry;\\n  }\\n\\n  ///////////////////\\n  // VAULT ACTIONS //\\n  ///////////////////\\n\\n  /**\\n   * @dev convert premium in quote asset into collateral asset and send it back to the vault.\\n   */\\n  function returnFundsAndClearStrikes() external onlyVault {\\n    // exchange asset back to collateral asset and send it back to the vault\\n    _returnFundsToVault();\\n\\n    // keep internal storage data on old strikes and positions ids\\n    _clearAllActiveStrikes();\\n  }\\n\\n  /**\\n   * @notice sell a fix aomunt of options and collect premium\\n   * @dev the vault should pass in a strike id, and the strategy would verify if the strike is valid on-chain.\\n   * @param strikeId lyra strikeId to trade\\n   * @param lyraRewardRecipient address to receive trading reward. This need to be whitelisted\\n   * @return positionId\\n   * @return premiumReceived\\n   */\\n  function doTrade(uint strikeId, address lyraRewardRecipient)\\n    external\\n    onlyVault\\n    returns (\\n      uint positionId,\\n      uint premiumReceived,\\n      uint collateralToAdd\\n    )\\n  {\\n    // validate trade\\n    require(\\n      lastTradeTimestamp[strikeId] + strategyDetail.minTradeInterval <= block.timestamp,\\n      \\\"min time interval not passed\\\"\\n    );\\n    require(_isValidVolVariance(strikeId), \\\"vol variance exceeded\\\");\\n\\n    Strike memory strike = _getStrikes(_toDynamic(strikeId))[0];\\n    require(isValidStrike(strike), \\\"invalid strike\\\");\\n\\n    uint setCollateralTo;\\n    (collateralToAdd, setCollateralTo) = getRequiredCollateral(strike);\\n\\n    require(\\n      collateralAsset.transferFrom(address(vault), address(this), collateralToAdd),\\n      \\\"collateral transfer from vault failed\\\"\\n    );\\n\\n    (positionId, premiumReceived) = _sellStrike(strike, setCollateralTo, lyraRewardRecipient);\\n  }\\n\\n  /**\\n   * @dev calculate required collateral to add in the next trade.\\n   * sell size is fixed as strategyDetail.size\\n   * only add collateral if the additional sell will make the position out of buffer range\\n   * never remove collateral from an existing position\\n   */\\n  function getRequiredCollateral(Strike memory strike)\\n    public\\n    view\\n    returns (uint collateralToAdd, uint setCollateralTo)\\n  {\\n    uint sellAmount = strategyDetail.size;\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n\\n    // get existing position info if active\\n    uint existingAmount = 0;\\n    uint existingCollateral = 0;\\n    if (_isActiveStrike(strike.id)) {\\n      OptionPosition memory position = _getPositions(_toDynamic(strikeToPositionId[strike.id]))[0];\\n      existingCollateral = position.collateral;\\n      existingAmount = position.amount;\\n    }\\n\\n    // gets minBufferCollat for the whole position\\n    uint minBufferCollateral = _getBufferCollateral(\\n      strike.strikePrice,\\n      strike.expiry,\\n      exchangeParams.spotPrice,\\n      existingAmount + sellAmount\\n    );\\n\\n    // get targetCollat for this trade instance\\n    // prevents vault from adding excess collat just to meet targetCollat\\n    uint targetCollat = existingCollateral +\\n      _getFullCollateral(strike.strikePrice, sellAmount).multiplyDecimal(strategyDetail.collatPercent);\\n\\n    // if excess collateral, keep in position to encourage more option selling\\n    setCollateralTo = _max(_max(minBufferCollateral, targetCollat), existingCollateral);\\n\\n    // existingCollateral is never > setCollateralTo\\n    collateralToAdd = setCollateralTo - existingCollateral;\\n  }\\n\\n  /**\\n   * @dev perform the trade\\n   * @param strike strike detail\\n   * @param setCollateralTo target collateral amount\\n   * @param lyraRewardRecipient address to receive lyra trading reward\\n   * @return positionId\\n   * @return premiumReceived\\n   */\\n  function _sellStrike(\\n    Strike memory strike,\\n    uint setCollateralTo,\\n    address lyraRewardRecipient\\n  ) internal returns (uint, uint) {\\n    // get minimum expected premium based on minIv\\n    uint minExpectedPremium = _getPremiumLimit(strike, strategyDetail.minVol, strategyDetail.size);\\n    // perform trade\\n    TradeResult memory result = _openPosition(\\n      TradeInputParameters({\\n        strikeId: strike.id,\\n        positionId: strikeToPositionId[strike.id],\\n        iterations: 3,\\n        optionType: optionType,\\n        amount: strategyDetail.size,\\n        setCollateralTo: setCollateralTo,\\n        minTotalCost: minExpectedPremium,\\n        maxTotalCost: type(uint).max,\\n        rewardRecipient: lyraRewardRecipient // set to zero address if don't want to wait for whitelist\\n      })\\n    );\\n    lastTradeTimestamp[strike.id] = block.timestamp;\\n\\n    // update active strikes\\n    _addActiveStrike(strike.id, result.positionId);\\n\\n    require(result.totalCost >= minExpectedPremium, \\\"premium received is below min expected premium\\\");\\n\\n    return (result.positionId, result.totalCost);\\n  }\\n\\n  /**\\n   * @dev use premium in strategy to reduce position size if collateral ratio is out of range\\n   */\\n  function reducePosition(\\n    uint positionId,\\n    uint closeAmount,\\n    address lyraRewardRecipient\\n  ) external onlyVault {\\n    OptionPosition memory position = _getPositions(_toDynamic(positionId))[0];\\n    Strike memory strike = _getStrikes(_toDynamic(position.strikeId))[0];\\n    require(strikeToPositionId[position.strikeId] == positionId, \\\"invalid positionId\\\");\\n\\n    // only allows closing if collat < minBuffer\\n    require(\\n      closeAmount <= getAllowedCloseAmount(position, strike.strikePrice, strike.expiry),\\n      \\\"amount exceeds allowed close amount\\\"\\n    );\\n\\n    // closes excess position with premium balance\\n    uint maxExpectedPremium = _getPremiumLimit(strike, strategyDetail.maxVol, strategyDetail.size);\\n    _formatedCloseOrForceClosePosition(position, closeAmount, 0, maxExpectedPremium, lyraRewardRecipient);\\n\\n    // return closed collateral amount\\n    if (_isBaseCollat()) {\\n      uint currentBal = baseAsset.balanceOf(address(this));\\n      baseAsset.transfer(address(vault), currentBal);\\n    } else {\\n      // quote collateral\\n      quoteAsset.transfer(address(vault), closeAmount);\\n    }\\n  }\\n\\n  /**\\n   * @dev close all outstanding positions regardless of collat and send funds back to vault\\n   */\\n  function emergencyCloseAll(address lyraRewardRecipient) external onlyVault {\\n    // the vault might not hold enough sUSD to close all positions, will need someone to tapup before doing so.\\n    for (uint i = 0; i < activeStrikeIds.length; i++) {\\n      uint strikeId = activeStrikeIds[i];\\n      OptionPosition memory position = _getPositions(_toDynamic(strikeToPositionId[strikeId]))[0];\\n      // revert if position state is not settled\\n      _formatedCloseOrForceClosePosition(position, position.amount, 0, type(uint).max, lyraRewardRecipient);\\n      delete strikeToPositionId[strikeId];\\n      delete lastTradeTimestamp[strikeId];\\n    }\\n\\n    _returnFundsToVault();\\n  }\\n\\n  /**\\n   * @dev calculates the position amount required to stay above the buffer collateral\\n   */\\n  function getAllowedCloseAmount(\\n    OptionPosition memory position,\\n    uint strikePrice,\\n    uint strikeExpiry\\n  ) public view returns (uint closeAmount) {\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n    uint minCollatPerAmount = _getBufferCollateral(strikePrice, strikeExpiry, exchangeParams.spotPrice, 1e18);\\n\\n    closeAmount = position.collateral < minCollatPerAmount.multiplyDecimal(position.amount)\\n      ? position.amount - position.collateral.divideDecimal(minCollatPerAmount)\\n      : 0;\\n  }\\n\\n  /////////////////////////////\\n  // Trade Parameter Helpers //\\n  /////////////////////////////\\n\\n  function _getFullCollateral(uint strikePrice, uint amount) internal view returns (uint fullCollat) {\\n    // calculate required collat based on collatBuffer and collatPercent\\n    fullCollat = _isBaseCollat() ? amount : amount.multiplyDecimal(strikePrice);\\n  }\\n\\n  /**\\n   * @dev get amount of collateral needed for shorting {amount} of strike, according to the strategy\\n   */\\n  function _getBufferCollateral(\\n    uint strikePrice,\\n    uint expiry,\\n    uint spotPrice,\\n    uint amount\\n  ) internal view returns (uint) {\\n    uint minCollat = _getMinCollateral(optionType, strikePrice, expiry, spotPrice, amount);\\n    uint minCollatWithBuffer = minCollat.multiplyDecimal(strategyDetail.collatBuffer);\\n\\n    uint fullCollat = _getFullCollateral(strikePrice, amount);\\n\\n    return _min(minCollatWithBuffer, fullCollat);\\n  }\\n\\n  /////////////////\\n  // Validation ///\\n  /////////////////\\n\\n  /**\\n   * @dev verify if the strike is valid for the strategy\\n   * @return isValid true if vol is withint [minVol, maxVol] and delta is within targetDelta +- maxDeltaGap\\n   */\\n  function isValidStrike(Strike memory strike) public view returns (bool isValid) {\\n    if (activeExpiry != strike.expiry) {\\n      return false;\\n    }\\n\\n    uint[] memory strikeId = _toDynamic(strike.id);\\n    uint vol = _getVols(strikeId)[0];\\n    int callDelta = _getDeltas(strikeId)[0];\\n    int delta = _isCall() ? callDelta : callDelta - SignedDecimalMath.UNIT;\\n    uint deltaGap = _abs(strategyDetail.targetDelta - delta);\\n    return vol >= strategyDetail.minVol && vol <= strategyDetail.maxVol && deltaGap < strategyDetail.maxDeltaGap;\\n  }\\n\\n  /**\\n   * @dev check if the vol variance for the given strike is within certain range\\n   */\\n  function _isValidVolVariance(uint strikeId) internal view returns (bool isValid) {\\n    uint volGWAV = _volGWAV(strikeId, strategyDetail.gwavPeriod);\\n    uint volSpot = _getVols(_toDynamic(strikeId))[0];\\n\\n    uint volDiff = (volGWAV >= volSpot) ? volGWAV - volSpot : volSpot - volGWAV;\\n\\n    return isValid = volDiff < strategyDetail.maxVolVariance;\\n  }\\n\\n  /**\\n   * @dev check if the expiry of the board is valid according to the strategy\\n   */\\n  function _isValidExpiry(uint expiry) public view returns (bool isValid) {\\n    uint secondsToExpiry = _getSecondsToExpiry(expiry);\\n    isValid = (secondsToExpiry >= strategyDetail.minTimeToExpiry && secondsToExpiry <= strategyDetail.maxTimeToExpiry);\\n  }\\n}\\n\",\"keccak256\":\"0xefd48dc69693f97a0d8380110c7ed7fd464505ebdcb330af24c3d3f8db6fb96e\",\"license\":\"MIT\"},\"contracts/strategies/StrategyBase.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// Lyra\\nimport {LyraAdapter} from \\\"@lyrafinance/protocol/contracts/periphery/LyraAdapter.sol\\\";\\n\\n// Libraries\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {LyraVault} from \\\"../core/LyraVault.sol\\\";\\nimport {DecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/DecimalMath.sol\\\";\\nimport {SignedDecimalMath} from \\\"@lyrafinance/protocol/contracts/synthetix/SignedDecimalMath.sol\\\";\\n\\ncontract StrategyBase is LyraAdapter {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  LyraVault public immutable vault;\\n  OptionType public immutable optionType;\\n\\n  /// @dev asset used as collateral in AMM to sell. Should be the same as vault asset\\n  IERC20 public collateralAsset;\\n\\n  mapping(uint => uint) public lastTradeTimestamp;\\n\\n  uint[] public activeStrikeIds;\\n  mapping(uint => uint) public strikeToPositionId;\\n\\n  ///////////\\n  // ADMIN //\\n  ///////////\\n\\n  modifier onlyVault() virtual {\\n    require(msg.sender == address(vault), \\\"only Vault\\\");\\n    _;\\n  }\\n\\n  constructor(LyraVault _vault, OptionType _optionType) LyraAdapter() {\\n    vault = _vault;\\n    optionType = _optionType;\\n  }\\n\\n  function initAdapter(\\n    address _lyraRegistry,\\n    address _optionMarket,\\n    address _curveSwap,\\n    address _feeCounter\\n  ) external onlyOwner {\\n    // set addresses for LyraAdapter\\n    setLyraAddresses(_lyraRegistry, _optionMarket, _curveSwap, _feeCounter);\\n\\n    quoteAsset.approve(address(vault), type(uint).max);\\n    baseAsset.approve(address(vault), type(uint).max);\\n    collateralAsset = _isBaseCollat() ? IERC20(address(baseAsset)) : IERC20(address(quoteAsset));\\n  }\\n\\n  ///////////////////\\n  // VAULT ACTIONS //\\n  ///////////////////\\n\\n  /**\\n   * @dev exchange asset back to collateral asset and send it back to the vault\\n   * @dev override this function if you want to customize asset management flow\\n   */\\n  function _returnFundsToVault() internal virtual {\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n    uint quoteBal = quoteAsset.balanceOf(address(this));\\n\\n    if (_isBaseCollat()) {\\n      // exchange quote asset to base asset, and send base asset back to vault\\n      uint baseBal = baseAsset.balanceOf(address(this));\\n      uint minQuoteExpected = quoteBal.divideDecimal(exchangeParams.spotPrice).multiplyDecimal(\\n        DecimalMath.UNIT - exchangeParams.baseQuoteFeeRate\\n      );\\n      uint baseReceived = _exchangeFromExactQuote(quoteBal, minQuoteExpected);\\n      require(baseAsset.transfer(address(vault), baseBal + baseReceived), \\\"failed to return funds from strategy\\\");\\n    } else {\\n      // send quote balance directly\\n      require(quoteAsset.transfer(address(vault), quoteBal), \\\"failed to return funds from strategy\\\");\\n    }\\n  }\\n\\n  /////////////////////////////\\n  // Trade Parameter Helpers //\\n  /////////////////////////////\\n\\n  /**\\n   * @dev Automatically decide between close and forceClose\\n   * depending on whether deltaCutoff or tradingCutoff are crossed\\n   */\\n\\n  function _formatedCloseOrForceClosePosition(\\n    OptionPosition memory position,\\n    uint closeAmount,\\n    uint minTotalCost,\\n    uint maxTotalCost,\\n    address lyraRewardRecipient\\n  ) internal {\\n    // closes excess position with premium balance\\n\\n    // if it's a full close, take out our collateral as well.\\n    uint setCollateralTo = position.amount == closeAmount ? 0 : position.collateral;\\n\\n    TradeInputParameters memory tradeParams = TradeInputParameters({\\n      strikeId: position.strikeId,\\n      positionId: position.positionId,\\n      iterations: 3,\\n      optionType: optionType,\\n      amount: closeAmount,\\n      setCollateralTo: setCollateralTo,\\n      minTotalCost: minTotalCost,\\n      maxTotalCost: maxTotalCost,\\n      rewardRecipient: lyraRewardRecipient // set to zero address if don't want to wait for whitelist\\n    });\\n\\n    // if forceClosed, will pay less competitive price to close position but bypasses Lyra delta/trading cutoffs\\n    TradeResult memory result = _closeOrForceClosePosition(tradeParams);\\n    require(result.totalCost <= maxTotalCost, \\\"premium paid is above max expected premium\\\");\\n  }\\n\\n  /**\\n   * @dev get minimum premium that the vault should receive.\\n   * param listingId lyra option listing id\\n   * param size size of trade in Lyra standard sizes\\n   */\\n  function _getPremiumLimit(\\n    Strike memory strike,\\n    uint vol,\\n    uint size\\n  ) internal view returns (uint limitPremium) {\\n    ExchangeRateParams memory exchangeParams = _getExchangeParams();\\n    (uint callPremium, uint putPremium) = _getPurePremium(\\n      _getSecondsToExpiry(strike.expiry),\\n      vol,\\n      exchangeParams.spotPrice,\\n      strike.strikePrice\\n    );\\n\\n    limitPremium = _isCall() ? callPremium.multiplyDecimal(size) : putPremium.multiplyDecimal(size);\\n  }\\n\\n  //////////////////////////////\\n  // Active Strike Management //\\n  //////////////////////////////\\n\\n  /**\\n   * @dev add strike id to activeStrikeIds array\\n   */\\n  function _addActiveStrike(uint strikeId, uint tradedPositionId) internal {\\n    if (!_isActiveStrike(strikeId)) {\\n      strikeToPositionId[strikeId] = tradedPositionId;\\n      activeStrikeIds.push(strikeId);\\n    }\\n  }\\n\\n  /**\\n   * @dev add the last traded timestamp for a specific strike.\\n   */\\n  function _setLastTradedAt(uint strikeId, uint timestamp) internal {\\n    lastTradeTimestamp[strikeId] = timestamp;\\n  }\\n\\n  /**\\n   * @dev remove position data opened in the current round.\\n   * this can only be called after the position is settled by lyra\\n   **/\\n  function _clearAllActiveStrikes() internal {\\n    if (activeStrikeIds.length != 0) {\\n      for (uint i = 0; i < activeStrikeIds.length; i++) {\\n        uint strikeId = activeStrikeIds[i];\\n        OptionPosition memory position = _getPositions(_toDynamic(strikeToPositionId[strikeId]))[0];\\n        // revert if position state is not settled\\n        require(position.state != PositionState.ACTIVE, \\\"cannot clear active position\\\");\\n        delete strikeToPositionId[strikeId];\\n        delete lastTradeTimestamp[strikeId];\\n      }\\n      delete activeStrikeIds;\\n    }\\n  }\\n\\n  function _isActiveStrike(uint strikeId) internal view returns (bool isActive) {\\n    isActive = strikeToPositionId[strikeId] != 0;\\n  }\\n\\n  //////////\\n  // Misc //\\n  //////////\\n\\n  function _isBaseCollat() internal view returns (bool isBase) {\\n    isBase = (optionType == OptionType.SHORT_CALL_BASE) ? true : false;\\n  }\\n\\n  function _isCall() internal view returns (bool isCall) {\\n    isCall = (optionType == OptionType.SHORT_PUT_QUOTE || optionType == OptionType.LONG_PUT) ? false : true;\\n  }\\n\\n  function _getSecondsToExpiry(uint expiry) internal view returns (uint) {\\n    require(block.timestamp <= expiry, \\\"timestamp expired\\\");\\n    return expiry - block.timestamp;\\n  }\\n\\n  function _abs(int val) internal pure returns (uint) {\\n    return val >= 0 ? uint(val) : uint(-val);\\n  }\\n\\n  function _min(uint x, uint y) internal pure returns (uint) {\\n    return (x < y) ? x : y;\\n  }\\n\\n  function _max(uint x, uint y) internal pure returns (uint) {\\n    return (x > y) ? x : y;\\n  }\\n\\n  // temporary fix - eth core devs promised Q2 2022 fix\\n  function _toDynamic(uint val) internal pure returns (uint[] memory dynamicArray) {\\n    dynamicArray = new uint[](1);\\n    dynamicArray[0] = val;\\n  }\\n}\\n\",\"keccak256\":\"0xd1858e918a8f44f3fc3a8cbb21991c257d915c9aa24827f74523872ab6228657\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x516a22876c1fab47f49b1bc22b4614491cd05338af8bd2e7b382da090a079990\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"openzeppelin-contracts-4.4.1/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162005032380380620050328339810160408190526200003491620000d8565b8181620000413362000088565b6001600160a01b03821660805280600481111562000063576200006362000125565b60a08160048111156200007a576200007a62000125565b81525050505050506200013b565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008060408385031215620000ec57600080fd5b82516001600160a01b03811681146200010457600080fd5b6020840151909250600581106200011a57600080fd5b809150509250929050565b634e487b7160e01b600052602160045260246000fd5b60805160a051614e4c620001e6600039600081816105e9015281816120240152818161205f01528181612430015281816124f3015281816127d60152612e8f01526000818161059c0152818161086201528181610a5201528181610afa01528181610d4d01528181610fbc0152818161106b01528181611172015281816112920152818161130b015281816114e20152818161161301528181612a7f0152612bb00152614e4c6000f3fe608060405234801561001057600080fd5b506004361061025c5760003560e01c80638da5cb5b11610145578063cdf456e1116100bd578063f2fde38b1161008c578063fdf262b711610071578063fdf262b7146105be578063ffcd00ac146105d1578063ffd9eedb146105e457600080fd5b8063f2fde38b14610584578063fbfa77cf1461059757600080fd5b8063cdf456e11461052b578063d4aaa9eb1461053e578063d8fca1ac1461055e578063ee9e0e6a1461057157600080fd5b8063ae74fc4d11610114578063bb4a9f88116100f9578063bb4a9f88146104f2578063bc4e440514610505578063cae1c5821461051857600080fd5b8063ae74fc4d146104cc578063b5ca94a0146104df57600080fd5b80638da5cb5b14610467578063a65be9ba14610478578063a8c379c21461048b578063aabaecd6146104b957600080fd5b80635cf03549116101d85780637083a904116101a75780637dd0db1b1161018c5780637dd0db1b1461043957806383cea5421461044c578063870dcaeb1461045457600080fd5b80637083a9041461041e578063715018a61461043157600080fd5b80635cf03549146103dd578063619a84cc146103f0578063621318cd146103f8578063665a11ca1461040b57600080fd5b806338b740541161022f57806354f1e01f1161021457806354f1e01f1461038d57806357949815146103b55780635a3c76ab146103c857600080fd5b806338b7405414610357578063478620c01461036a57600080fd5b806303c4d3d614610261578063131b2f861461027d5780632a37ad5a1461029d5780632bab754b1461032c575b600080fd5b61026a601e5481565b6040519081526020015b60405180910390f35b61026a61028b36600461400b565b600f6020526000908152604090205481565b601254601354601454601554601654601754601854601954601a54601b54601c54601d546102d39b9a999897969594939291908c565b604080519c8d5260208d019b909b52998b019890985260608a0196909652608089019490945260a088019290925260c087015260e086015261010085015261012084015261014083015261016082015261018001610274565b60045461033f906001600160a01b031681565b6040516001600160a01b039091168152602001610274565b60095461033f906001600160a01b031681565b61037d610378366004614147565b610618565b6040519015158152602001610274565b6103a061039b366004614147565b610705565b60408051928352602083019190915201610274565b600d5461033f906001600160a01b031681565b6103db6103d6366004614197565b6107ff565b005b6103db6103eb36600461424b565b6109d2565b6103db610bd8565b61037d61040636600461400b565b610d18565b60055461033f906001600160a01b031681565b6103db61042c3660046142a7565b610d42565b6103db611101565b6103db6104473660046142e0565b611167565b6103db611287565b60065461033f906001600160a01b031681565b6000546001600160a01b031661033f565b60075461033f906001600160a01b031681565b61049e6104993660046142fd565b6112fc565b60408051938452602084019290925290820152606001610274565b600e5461033f906001600160a01b031681565b6103db6104da36600461400b565b611608565b6103db6104ed36600461424b565b6116dd565b60035461033f906001600160a01b031681565b61026a61051336600461400b565b611b9c565b60085461033f906001600160a01b031681565b600b5461033f906001600160a01b031681565b61026a61054c36600461400b565b60116020526000908152604090205481565b600c5461033f906001600160a01b031681565b60015461033f906001600160a01b031681565b6103db6105923660046142e0565b611bbd565b61033f7f000000000000000000000000000000000000000000000000000000000000000081565b600a5461033f906001600160a01b031681565b61026a6105df366004614347565b611c9c565b61060b7f000000000000000000000000000000000000000000000000000000000000000081565b6040516102749190614408565b60008160200151601e541461062f57506000919050565b600061063e8360000151611d15565b9050600061064b82611d5c565b60008151811061065d5761065d61441b565b60200260200101519050600061067283611eb0565b6000815181106106845761068461441b565b60200260200101519050600061069861201e565b6106b7576106a86012600a61452b565b6106b29083614537565b6106b9565b815b905060006106d6826012600201546106d19190614537565b6120a1565b60165490915084108015906106ed57506017548411155b80156106fa575060155481105b979650505050505050565b6018546000908190816107166120c1565b8551600090815260116020526040812054919250908190156107815786516000908152601160205260408120546107559061075090611d15565b6121a9565b6000815181106107675761076761441b565b602002602001015190508060800151915080606001519250505b60006107a688604001518960200151866000015188876107a1919061458f565b612428565b905060006107c76012600b01546107c18b6040015189612492565b906124b5565b6107d1908461458f565b90506107e66107e083836124d7565b846124d7565b96506107f283886145a7565b9750505050505050915091565b6000546001600160a01b0316331461085e5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632728f3336040518163ffffffff1660e01b81526004016101006040518083038186803b1580156108ba57600080fd5b505afa1580156108ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f2919061460b565b975050505050505050801561096f5760405162461bcd60e51b815260206004820152602960248201527f63616e6e6f74206368616e676520737472617465677920696620726f756e642060448201527f69732061637469766500000000000000000000000000000000000000000000006064820152608401610855565b508051601255602081015160135560408101516014556060810151601555608081015160165560a081015160175560c081015160185560e0810151601955610100810151601a55610120810151601b55610140810151601c556101600151601d55565b6000546001600160a01b03163314610a2c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b610a38848484846116dd565b600a5460405163095ea7b360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260001960248301529091169063095ea7b390604401602060405180830381600087803b158015610aa757600080fd5b505af1158015610abb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610adf919061469d565b50600b5460405163095ea7b360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260001960248301529091169063095ea7b390604401602060405180830381600087803b158015610b4f57600080fd5b505af1158015610b63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b87919061469d565b50610b906124ed565b610ba557600a546001600160a01b0316610bb2565b600b546001600160a01b03165b600e80546001600160a01b0319166001600160a01b039290921691909117905550505050565b6000546001600160a01b03163314610c325760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b600260009054906101000a90046001600160a01b03166001600160a01b0316633535c97b6040518163ffffffff1660e01b815260040160206040518083038186803b158015610c8057600080fd5b505afa158015610c94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb891906146c3565b60025460405163447fbc6360e01b81526001600160a01b03918216600482015291169063447fbc6390602401600060405180830381600087803b158015610cfe57600080fd5b505af1158015610d12573d6000803e3d6000fd5b50505050565b600080610d2483612534565b6012549091508110801590610d3b57506013548111155b9392505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610da75760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b6000610db561075085611d15565b600081518110610dc757610dc761441b565b602002602001015190506000610de8610de38360200151611d15565b612590565b600081518110610dfa57610dfa61441b565b602002602001015190508460116000846020015181526020019081526020016000205414610e6a5760405162461bcd60e51b815260206004820152601260248201527f696e76616c696420706f736974696f6e496400000000000000000000000000006044820152606401610855565b610e7d8282604001518360200151611c9c565b841115610ef25760405162461bcd60e51b815260206004820152602360248201527f616d6f756e74206578636565647320616c6c6f77656420636c6f736520616d6f60448201527f756e7400000000000000000000000000000000000000000000000000000000006064820152608401610855565b6000610f0982601260050154601260060154612736565b9050610f1983866000848861278f565b610f216124ed565b1561105157600b546040516370a0823160e01b81523060048201526000916001600160a01b0316906370a082319060240160206040518083038186803b158015610f6a57600080fd5b505afa158015610f7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa291906146e0565b600b5460405163a9059cbb60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820184905292935091169063a9059cbb90604401602060405180830381600087803b15801561101257600080fd5b505af1158015611026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104a919061469d565b50506110f9565b600a5460405163a9059cbb60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018890529091169063a9059cbb90604401602060405180830381600087803b1580156110bf57600080fd5b505af11580156110d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110f7919061469d565b505b505050505050565b6000546001600160a01b0316331461115b5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b61116560006128c3565b565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146111cc5760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b60005b60105481101561127b576000601082815481106111ee576111ee61441b565b90600052602060002001549050600061121c6107506011600085815260200190815260200160002054611d15565b60008151811061122e5761122e61441b565b6020026020010151905061124c81826060015160006000198861278f565b506000908152601160209081526040808320839055600f90915281205580611273816146f9565b9150506111cf565b50611284612913565b50565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146112ec5760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b6112f4612913565b611165612c98565b60008080336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146113655760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b6019546000868152600f602052604090205442916113829161458f565b11156113d05760405162461bcd60e51b815260206004820152601c60248201527f6d696e2074696d6520696e74657276616c206e6f7420706173736564000000006044820152606401610855565b6113d985612dbf565b6114255760405162461bcd60e51b815260206004820152601560248201527f766f6c2076617269616e636520657863656564656400000000000000000000006044820152606401610855565b6000611433610de387611d15565b6000815181106114455761144561441b565b6020026020010151905061145881610618565b6114a45760405162461bcd60e51b815260206004820152600e60248201527f696e76616c696420737472696b650000000000000000000000000000000000006044820152606401610855565b60006114af82610705565b600e546040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301523060248301526044820185905293965091935091909116906323b872dd90606401602060405180830381600087803b15801561154357600080fd5b505af1158015611557573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061157b919061469d565b6115ed5760405162461bcd60e51b815260206004820152602560248201527f636f6c6c61746572616c207472616e736665722066726f6d207661756c74206660448201527f61696c65640000000000000000000000000000000000000000000000000000006064820152608401610855565b6115f8828288612e32565b9098909750929550919350505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461166d5760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b600061167882612fa7565b90506116878160200151610d18565b6116d35760405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420626f617264000000000000000000000000000000000000006044820152606401610855565b60200151601e5550565b6000546001600160a01b031633146117375760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b600a546001600160a01b0316156117d257600a5460035460405163095ea7b360e01b81526001600160a01b0391821660048201526000602482015291169063095ea7b390604401602060405180830381600087803b15801561179857600080fd5b505af11580156117ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d0919061469d565b505b600b546001600160a01b03161561186d57600b5460035460405163095ea7b360e01b81526001600160a01b0391821660048201526000602482015291169063095ea7b390604401602060405180830381600087803b15801561183357600080fd5b505af1158015611847573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061186b919061469d565b505b600380546001600160a01b038581166001600160a01b0319928316179092556001805492871692909116821790556040517f7f2e06000000000000000000000000000000000000000000000000000000000081527f53594e5448455449585f414441505445520000000000000000000000000000006004820152637f2e06009060240160206040518083038186803b15801561190857600080fd5b505afa15801561191c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194091906146c3565b600280546001600160a01b0319166001600160a01b039290921691909117905561196861309f565b600c80546001600160a01b038085166001600160a01b031992831617909255600d80548484169216919091179055600254604080517f3535c97b00000000000000000000000000000000000000000000000000000000815290519190921691633535c97b916004808301926020929190829003018186803b1580156119ec57600080fd5b505afa158015611a00573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a2491906146c3565b60025460405163447fbc6360e01b81526001600160a01b03918216600482015291169063447fbc6390602401600060405180830381600087803b158015611a6a57600080fd5b505af1158015611a7e573d6000803e3d6000fd5b5050600a5460035460405163095ea7b360e01b81526001600160a01b03918216600482015260001960248201529116925063095ea7b39150604401602060405180830381600087803b158015611ad357600080fd5b505af1158015611ae7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b0b919061469d565b50600b5460035460405163095ea7b360e01b81526001600160a01b039182166004820152600019602482015291169063095ea7b390604401602060405180830381600087803b158015611b5d57600080fd5b505af1158015611b71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b95919061469d565b5050505050565b60108181548110611bac57600080fd5b600091825260209091200154905081565b6000546001600160a01b03163314611c175760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b6001600160a01b038116611c935760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610855565b611284816128c3565b600080611ca76120c1565b90506000611cc385858460000151670de0b6b3a7640000612428565b9050611cdc8660600151826124b590919063ffffffff16565b866080015110611ced576000611d0b565b6080860151611cfc90826131ee565b8660600151611d0b91906145a7565b9695505050505050565b604080516001808252818301909252606091602080830190803683370190505090508181600081518110611d4b57611d4b61441b565b602002602001018181525050919050565b80516060908067ffffffffffffffff811115611d7a57611d7a614024565b604051908082528060200260200182016040528015611da3578160200160208202803683370190505b50915060005b81811015611ea957600354845160009182916001600160a01b039091169063c4c4a0d090889086908110611ddf57611ddf61441b565b60200260200101516040518263ffffffff1660e01b8152600401611e0591815260200190565b60006040518083038186803b158015611e1d57600080fd5b505afa158015611e31573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611e599190810190614881565b91509150611e78826040015182604001516124b590919063ffffffff16565b858481518110611e8a57611e8a61441b565b602002602001018181525050505080611ea2906146f9565b9050611da9565b5050919050565b80516060908067ffffffffffffffff811115611ece57611ece614024565b604051908082528060200260200182016040528015611ef7578160200160208202803683370190505b50915060005b81811015611ea9576000611f29858381518110611f1c57611f1c61441b565b6020026020010151613207565b604080517f8d31f3aa00000000000000000000000000000000000000000000000000000000815282516004820152602083015160248201529082015160448201526060820151606482015260808201516084820152909150733AE81479aBEeA6b451e070F955eDDFf1Bc70C00b90638d31f3aa9060a401604080518083038186803b158015611fb757600080fd5b505af4158015611fcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fef91906148d2565b508483815181106120025761200261441b565b602090810291909101015250612017816146f9565b9050611efd565b600060047f00000000000000000000000000000000000000000000000000000000000000006004811115612054576120546143d4565b1480612091575060017f0000000000000000000000000000000000000000000000000000000000000000600481111561208f5761208f6143d4565b145b61209b5750600190565b50600090565b6000808212156120b9576120b4826148f6565b6120bb565b815b92915050565b6120e560405180606001604052806000815260200160008152602001600081525090565b6002546003546040517fcfbe7f440000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152600092919091169063cfbe7f449060240160a06040518083038186803b15801561214a57600080fd5b505afa15801561215e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121829190614913565b60408051606080820183528351825283015160208201526080909201519082015292915050565b600480546040517f23d354770000000000000000000000000000000000000000000000000000000081526060926000926001600160a01b0316916323d35477916121f591879101614963565b60006040518083038186803b15801561220d57600080fd5b505afa158015612221573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261224991908101906149a7565b805190915060008167ffffffffffffffff81111561226957612269614024565b6040519080825280602002602001820160405280156122a257816020015b61228f613f27565b8152602001906001900390816122875790505b50905060005b8281101561241f576040518060c001604052808583815181106122cd576122cd61441b565b60200260200101516000015181526020018583815181106122f0576122f061441b565b60200260200101516020015181526020018583815181106123135761231361441b565b6020026020010151604001516004811115612330576123306143d4565b6004811115612341576123416143d4565b6004811115612352576123526143d4565b81526020018583815181106123695761236961441b565b602002602001015160600151815260200185838151811061238c5761238c61441b565b60200260200101516080015181526020018583815181106123af576123af61441b565b602002602001015160a0015160058111156123cc576123cc6143d4565b60058111156123dd576123dd6143d4565b60058111156123ee576123ee6143d4565b8152508282815181106124035761240361441b565b602002602001018190525080612418906146f9565b90506122a8565b50949350505050565b6000806124587f00000000000000000000000000000000000000000000000000000000000000008787878761345b565b601c5490915060009061246c9083906124b5565b9050600061247a8886612492565b90506124868282613506565b98975050505050505050565b600061249c6124ed565b6124af576124aa82846124b5565b610d3b565b50919050565b60006124c36012600a61452b565b6124cd8385614a95565b610d3b9190614ab4565b60008183116124e65781610d3b565b5090919050565b600060027f00000000000000000000000000000000000000000000000000000000000000006004811115612523576125236143d4565b1461252e5750600090565b50600190565b6000814211156125865760405162461bcd60e51b815260206004820152601160248201527f74696d657374616d7020657870697265640000000000000000000000000000006044820152606401610855565b6120bb42836145a7565b80516060908067ffffffffffffffff8111156125ae576125ae614024565b60405190808252806020026020018201604052801561261157816020015b6125fe6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b8152602001906001900390816125cc5790505b50915060005b81811015611ea957600354845160009182916001600160a01b039091169063c4c4a0d09088908690811061264d5761264d61441b565b60200260200101516040518263ffffffff1660e01b815260040161267391815260200190565b60006040518083038186803b15801561268b57600080fd5b505afa15801561269f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526126c79190810190614881565b915091506040518060a001604052808360000151815260200182602001518152602001836020015181526020018360400151815260200182604001518152508584815181106127185761271861441b565b602002602001018190525050508061272f906146f9565b9050612617565b6000806127416120c1565b90506000806127666127568860200151612534565b8785600001518a60400151613515565b9150915061277261201e565b6127855761278081866124b5565b6106fa565b6106fa82866124b5565b6000848660600151146127a65785608001516127a9565b60005b905060006040518061012001604052808860200151815260200188600001518152602001600381526020017f00000000000000000000000000000000000000000000000000000000000000006004811115612806576128066143d4565b8152602001878152602001838152602001868152602001858152602001846001600160a01b03168152509050600061283d8261369f565b905084816020015111156128b95760405162461bcd60e51b815260206004820152602a60248201527f7072656d69756d20706169642069732061626f7665206d61782065787065637460448201527f6564207072656d69756d000000000000000000000000000000000000000000006064820152608401610855565b5050505050505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600061291d6120c1565b600a546040516370a0823160e01b81523060048201529192506000916001600160a01b03909116906370a082319060240160206040518083038186803b15801561296657600080fd5b505afa15801561297a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061299e91906146e0565b90506129a86124ed565b15612b9657600b546040516370a0823160e01b81523060048201526000916001600160a01b0316906370a082319060240160206040518083038186803b1580156129f157600080fd5b505afa158015612a05573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a2991906146e0565b6040840151909150600090612a5b90612a446012600a61452b565b612a4e91906145a7565b85516107c19086906131ee565b90506000612a6984836136ff565b600b549091506001600160a01b031663a9059cbb7f0000000000000000000000000000000000000000000000000000000000000000612aa8848761458f565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b1681526001600160a01b0390921660048301526024820152604401602060405180830381600087803b158015612b0657600080fd5b505af1158015612b1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b3e919061469d565b611b955760405162461bcd60e51b8152602060048201526024808201527f6661696c656420746f2072657475726e2066756e64732066726f6d20737472616044820152637465677960e01b6064820152608401610855565b600a5460405163a9059cbb60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018490529091169063a9059cbb90604401602060405180830381600087803b158015612c0457600080fd5b505af1158015612c18573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c3c919061469d565b612c945760405162461bcd60e51b8152602060048201526024808201527f6661696c656420746f2072657475726e2066756e64732066726f6d20737472616044820152637465677960e01b6064820152608401610855565b5050565b601054156111655760005b601054811015612db257600060108281548110612cc257612cc261441b565b906000526020600020015490506000612cf06107506011600085815260200190815260200160002054611d15565b600081518110612d0257612d0261441b565b6020026020010151905060016005811115612d1f57612d1f6143d4565b8160a001516005811115612d3557612d356143d4565b1415612d835760405162461bcd60e51b815260206004820152601c60248201527f63616e6e6f7420636c6561722061637469766520706f736974696f6e000000006044820152606401610855565b506000908152601160209081526040808320839055600f90915281205580612daa816146f9565b915050612ca3565b5061116560106000613f7e565b600080612dd1836012600901546137f1565b90506000612de6612de185611d15565b611d5c565b600081518110612df857612df861441b565b60200260200101519050600081831015612e1b57612e1683836145a7565b612e25565b612e2582846145a7565b601a541195945050505050565b6000806000612e4c86601260040154601260060154612736565b90506000612ef560405180610120016040528089600001518152602001601160008b600001518152602001908152602001600020548152602001600381526020017f00000000000000000000000000000000000000000000000000000000000000006004811115612ebf57612ebf6143d4565b815260200160126006015481526020018881526020018481526020016000198152602001876001600160a01b031681525061388e565b87516000908152600f6020526040902042905587518151919250612f1891613a3d565b8181602001511015612f925760405162461bcd60e51b815260206004820152602e60248201527f7072656d69756d2072656365697665642069732062656c6f77206d696e20657860448201527f706563746564207072656d69756d0000000000000000000000000000000000006064820152608401610855565b80516020909101519097909650945050505050565b612fd26040518060800160405280600081526020016000815260200160008152602001606081525090565b6003546040517f16a54f50000000000000000000000000000000000000000000000000000000008152600481018490526000916001600160a01b0316906316a54f509060240160006040518083038186803b15801561303057600080fd5b505afa158015613044573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261306c9190810190614ad6565b60408051608080820183528351825260208085015190830152828401519282019290925291015160608201529392505050565b6001546003546040517fc4158a510000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152600092919091169063c4158a51906024016101606040518083038186803b15801561310557600080fd5b505afa158015613119573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061313d9190614b13565b8051600580546001600160a01b03199081166001600160a01b03938416179091556040830151600980548316918416919091179055608083015160088054831691841691909117905560a083015160048054831691841691909117905560e0830151600680548316918416919091179055610100830151600780548316918416919091179055610120830151600a8054831691841691909117905561014090920151600b8054909316911617905550565b6000816131fd6012600a61452b565b6124cd9085614a95565b6132396040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b6003546040517fc4c4a0d00000000000000000000000000000000000000000000000000000000081526004810184905260009182916001600160a01b039091169063c4c4a0d09060240160006040518083038186803b15801561329b57600080fd5b505afa1580156132af573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526132d79190810190614881565b915091506040518060a001604052804283602001516132f691906145a7565b8152602001613316846040015184604001516124b590919063ffffffff16565b81526002546003546040517f7dbae6480000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152602090930192911690637dbae6489060240160206040518083038186803b15801561337e57600080fd5b505afa158015613392573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133b691906146e0565b815260200183602001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561341457600080fd5b505afa158015613428573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061344c9190614bed565b61012001519052949350505050565b6009546000906001600160a01b031663a57ce682876004811115613481576134816143d4565b6004811115613492576134926143d4565b878787876040518663ffffffff1660e01b81526004016134b6959493929190614c74565b60206040518083038186803b1580156134ce57600080fd5b505afa1580156134e2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d0b91906146e0565b60008183106124e65781610d3b565b60008060006040518060a00160405280888152602001878152602001868152602001858152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561358c57600080fd5b505afa1580156135a0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135c49190614bed565b61012001519052604080517fb6e62e5900000000000000000000000000000000000000000000000000000000815282516004820152602083015160248201529082015160448201526060820151606482015260808201516084820152909150733AE81479aBEeA6b451e070F955eDDFf1Bc70C00b9063b6e62e599060a401604080518083038186803b15801561365957600080fd5b505af415801561366d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061369191906148d2565b909890975095505050505050565b6136c360405180606001604052806000815260200160008152602001600081525090565b81516136ce90613a93565b1580156136e3575081516136e190613b44565b155b156136f1576120bb82613bdc565b6120bb82613c1d565b919050565b6002546003546040517fae58cf0b0000000000000000000000000000000000000000000000000000000081526001600160a01b03918216600482015260248101859052600092919091169063ae58cf0b90604401602060405180830381600087803b15801561376d57600080fd5b505af1158015613781573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137a591906146e0565b9050818110156120bb576040517ff125dbc40000000000000000000000000000000000000000000000000000000081523060048201526024810183905260448101829052606401610855565b6007546040517f39a427f100000000000000000000000000000000000000000000000000000000815260048101849052602481018390526000916001600160a01b0316906339a427f19060440160206040518083038186803b15801561385657600080fd5b505afa15801561386a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3b91906146e0565b6138b260405180606001604052806000815260200160008152602001600081525090565b6003546000906001600160a01b03166237f2bc6138ce85613c5a565b6040518263ffffffff1660e01b81526004016138ea9190614ca2565b606060405180830381600087803b15801561390457600080fd5b505af1158015613918573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061393c9190614d06565b6101008401519091506001600160a01b031615613a1757600d546003546101008501516001600160a01b039283169263a4ed578192169061397c87613c5a565b60800151602086015160408088015190517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b1681526001600160a01b03958616600482015294909316602485015260448401919091526064830152608482015260a401600060405180830381600087803b1580156139fe57600080fd5b505af1158015613a12573d6000803e3d6000fd5b505050505b604080516060810182528251815260208084015190820152918101519082015292915050565b600082815260116020526040902054612c94576000828152601160205260408120919091556010805460018101825591527f1b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae6720155565b600080613a9e613cf6565b60408051600180825281830190925291925060009190602080830190803683370190505090508381600081518110613ad857613ad861441b565b6020026020010181815250506000613aef82611eb0565b600081518110613b0157613b0161441b565b602002602001015190508260600151601260ff16600a613b21919061452b565b613b2b9190614537565b811380613b3b5750826060015181125b95945050505050565b600080613b4f613cf6565b60408051600180825281830190925291925060009190602080830190803683370190505090508381600081518110613b8957613b8961441b565b6020026020010181815250506000613ba082612590565b600081518110613bb257613bb261441b565b602002602001015190508260800151428260200151613bd191906145a7565b111595945050505050565b613c0060405180606001604052806000815260200160008152602001600081525090565b6003546000906001600160a01b03166392b4632c6138ce85613c5a565b613c4160405180606001604052806000815260200160008152602001600081525090565b6003546000906001600160a01b031663e4e83e3d6138ce855b613c62613f9c565b60405180610100016040528083600001518152602001836020015181526020018360400151815260200183606001516004811115613ca257613ca26143d4565b6004811115613cb357613cb36143d4565b6004811115613cc457613cc46143d4565b8152602001836080015181526020018360a0015181526020018360c0015181526020018360e001518152509050919050565b613d2f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600854604080517fda53763100000000000000000000000000000000000000000000000000000000815290516000926001600160a01b03169163da53763191600480830192610120929190829003018186803b158015613d8e57600080fd5b505afa158015613da2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613dc69190614d62565b90506000600860009054906101000a90046001600160a01b03166001600160a01b031663ffae4b366040518163ffffffff1660e01b81526004016101806040518083038186803b158015613e1957600080fd5b505afa158015613e2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613e519190614d7f565b90506040518060c001604052808360e0015181526020018361010001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b158015613ec257600080fd5b505afa158015613ed6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613efa9190614bed565b61012001518152602001826000015181526020018260400151815260200182602001518152509250505090565b6040518060c00160405280600081526020016000815260200160006004811115613f5357613f536143d4565b8152602001600081526020016000815260200160006005811115613f7957613f796143d4565b905290565b50805460008255906000526020600020908101906112849190613ff2565b60405180610100016040528060008152602001600081526020016000815260200160006004811115613fd057613fd06143d4565b8152602001600081526020016000815260200160008152602001600081525090565b5b808211156140075760008155600101613ff3565b5090565b60006020828403121561401d57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff8111828210171561405d5761405d614024565b60405290565b604051610180810167ffffffffffffffff8111828210171561405d5761405d614024565b60405160c0810167ffffffffffffffff8111828210171561405d5761405d614024565b604051610120810167ffffffffffffffff8111828210171561405d5761405d614024565b604051610160810167ffffffffffffffff8111828210171561405d5761405d614024565b604051610140810167ffffffffffffffff8111828210171561405d5761405d614024565b604051601f8201601f1916810167ffffffffffffffff8111828210171561413f5761413f614024565b604052919050565b600060a0828403121561415957600080fd5b61416161403a565b82358152602083013560208201526040830135604082015260608301356060820152608083013560808201528091505092915050565b600061018082840312156141aa57600080fd5b6141b2614063565b823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101408084013581830152506101608084013581830152508091505092915050565b6001600160a01b038116811461128457600080fd5b6000806000806080858703121561426157600080fd5b843561426c81614236565b9350602085013561427c81614236565b9250604085013561428c81614236565b9150606085013561429c81614236565b939692955090935050565b6000806000606084860312156142bc57600080fd5b833592506020840135915060408401356142d581614236565b809150509250925092565b6000602082840312156142f257600080fd5b8135610d3b81614236565b6000806040838503121561431057600080fd5b82359150602083013561432281614236565b809150509250929050565b6005811061128457600080fd5b6006811061128457600080fd5b600080600083850361010081121561435e57600080fd5b60c081121561436c57600080fd5b50614375614087565b843581526020850135602082015260408501356143918161432d565b80604083015250606085013560608201526080850135608082015260a08501356143ba8161433a565b60a08201529560c0850135955060e0909401359392505050565b634e487b7160e01b600052602160045260246000fd5b6005811061128457634e487b7160e01b600052602160045260246000fd5b60208101614415836143ea565b91905290565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600181815b8085111561448257816000190482111561446857614468614431565b8085161561447557918102915b93841c939080029061444c565b509250929050565b600082614499575060016120bb565b816144a6575060006120bb565b81600181146144bc57600281146144c6576144e2565b60019150506120bb565b60ff8411156144d7576144d7614431565b50506001821b6120bb565b5060208310610133831016604e8410600b8410161715614505575081810a6120bb565b61450f8383614447565b806000190482111561452357614523614431565b029392505050565b6000610d3b838361448a565b600080831283600160ff1b0183128115161561455557614555614431565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01831381161561458957614589614431565b50500390565b600082198211156145a2576145a2614431565b500190565b6000828210156145b9576145b9614431565b500390565b80516cffffffffffffffffffffffffff811681146136fa57600080fd5b80516fffffffffffffffffffffffffffffffff811681146136fa57600080fd5b805180151581146136fa57600080fd5b600080600080600080600080610100898b03121561462857600080fd5b885161ffff8116811461463a57600080fd5b975061464860208a016145be565b965061465660408a016145be565b95506060890151945061466b60808a016145db565b935061467960a08a016145db565b925060c0890151915061468e60e08a016145fb565b90509295985092959890939650565b6000602082840312156146af57600080fd5b610d3b826145fb565b80516136fa81614236565b6000602082840312156146d557600080fd5b8151610d3b81614236565b6000602082840312156146f257600080fd5b5051919050565b600060001982141561470d5761470d614431565b5060010190565b6000610120828403121561472757600080fd5b61472f6140aa565b9050815181526020820151602082015260408201516040820152606082015160608201526080820151608082015260a082015160a082015260c082015160c082015260e082015160e082015261010080830151818301525092915050565b600067ffffffffffffffff8211156147a7576147a7614024565b5060051b60200190565b600060a082840312156147c357600080fd5b6147cb61403a565b90508151815260208083015181830152604083015160408301526147f1606084016145fb565b6060830152608083015167ffffffffffffffff81111561481057600080fd5b8301601f8101851361482157600080fd5b805161483461482f8261478d565b614116565b81815260059190911b8201830190838101908783111561485357600080fd5b928401925b8284101561487157835182529284019290840190614858565b6080860152509295945050505050565b600080610140838503121561489557600080fd5b61489f8484614714565b915061012083015167ffffffffffffffff8111156148bc57600080fd5b6148c8858286016147b1565b9150509250929050565b600080604083850312156148e557600080fd5b505080516020909101519092909150565b6000600160ff1b82141561490c5761490c614431565b5060000390565b600060a0828403121561492557600080fd5b61492d61403a565b82518152602083015160208201526040830151604082015260608301516060820152608083015160808201528091505092915050565b6020808252825182820181905260009190848201906040850190845b8181101561499b5783518352928401929184019160010161497f565b50909695505050505050565b600060208083850312156149ba57600080fd5b825167ffffffffffffffff8111156149d157600080fd5b8301601f810185136149e257600080fd5b80516149f061482f8261478d565b81815260c09182028301840191848201919088841115614a0f57600080fd5b938501935b83851015614a895780858a031215614a2c5760008081fd5b614a34614087565b855181528686015187820152604080870151614a4f8161432d565b90820152606086810151908201526080808701519082015260a080870151614a768161433a565b9082015283529384019391850191614a14565b50979650505050505050565b6000816000190483118215151615614aaf57614aaf614431565b500290565b600082614ad157634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215614ae857600080fd5b815167ffffffffffffffff811115614aff57600080fd5b614b0b848285016147b1565b949350505050565b60006101608284031215614b2657600080fd5b614b2e6140ce565b614b37836146b8565b8152614b45602084016146b8565b6020820152614b56604084016146b8565b6040820152614b67606084016146b8565b6060820152614b78608084016146b8565b6080820152614b8960a084016146b8565b60a0820152614b9a60c084016146b8565b60c0820152614bab60e084016146b8565b60e0820152610100614bbe8185016146b8565b90820152610120614bd08482016146b8565b90820152610140614be28482016146b8565b908201529392505050565b60006101408284031215614c0057600080fd5b614c086140f2565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152506101208084015181830152508091505092915050565b60a08101614c81876143ea565b95815260208101949094526040840192909252606083015260809091015290565b6000610100820190508251825260208301516020830152604083015160408301526060830151614cd1816143ea565b806060840152506080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015292915050565b600060608284031215614d1857600080fd5b6040516060810181811067ffffffffffffffff82111715614d3b57614d3b614024565b80604052508251815260208301516020820152604083015160408201528091505092915050565b60006101208284031215614d7557600080fd5b610d3b8383614714565b60006101808284031215614d9257600080fd5b614d9a614063565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e0820152610100808401518183015250610120808401518183015250610140808401518183015250610160614be28185016145fb56fea26469706673582212209caa9bf23dbba5652e9036ea01bd0da8675b2b2d11708304629e93cbea716d6e64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061025c5760003560e01c80638da5cb5b11610145578063cdf456e1116100bd578063f2fde38b1161008c578063fdf262b711610071578063fdf262b7146105be578063ffcd00ac146105d1578063ffd9eedb146105e457600080fd5b8063f2fde38b14610584578063fbfa77cf1461059757600080fd5b8063cdf456e11461052b578063d4aaa9eb1461053e578063d8fca1ac1461055e578063ee9e0e6a1461057157600080fd5b8063ae74fc4d11610114578063bb4a9f88116100f9578063bb4a9f88146104f2578063bc4e440514610505578063cae1c5821461051857600080fd5b8063ae74fc4d146104cc578063b5ca94a0146104df57600080fd5b80638da5cb5b14610467578063a65be9ba14610478578063a8c379c21461048b578063aabaecd6146104b957600080fd5b80635cf03549116101d85780637083a904116101a75780637dd0db1b1161018c5780637dd0db1b1461043957806383cea5421461044c578063870dcaeb1461045457600080fd5b80637083a9041461041e578063715018a61461043157600080fd5b80635cf03549146103dd578063619a84cc146103f0578063621318cd146103f8578063665a11ca1461040b57600080fd5b806338b740541161022f57806354f1e01f1161021457806354f1e01f1461038d57806357949815146103b55780635a3c76ab146103c857600080fd5b806338b7405414610357578063478620c01461036a57600080fd5b806303c4d3d614610261578063131b2f861461027d5780632a37ad5a1461029d5780632bab754b1461032c575b600080fd5b61026a601e5481565b6040519081526020015b60405180910390f35b61026a61028b36600461400b565b600f6020526000908152604090205481565b601254601354601454601554601654601754601854601954601a54601b54601c54601d546102d39b9a999897969594939291908c565b604080519c8d5260208d019b909b52998b019890985260608a0196909652608089019490945260a088019290925260c087015260e086015261010085015261012084015261014083015261016082015261018001610274565b60045461033f906001600160a01b031681565b6040516001600160a01b039091168152602001610274565b60095461033f906001600160a01b031681565b61037d610378366004614147565b610618565b6040519015158152602001610274565b6103a061039b366004614147565b610705565b60408051928352602083019190915201610274565b600d5461033f906001600160a01b031681565b6103db6103d6366004614197565b6107ff565b005b6103db6103eb36600461424b565b6109d2565b6103db610bd8565b61037d61040636600461400b565b610d18565b60055461033f906001600160a01b031681565b6103db61042c3660046142a7565b610d42565b6103db611101565b6103db6104473660046142e0565b611167565b6103db611287565b60065461033f906001600160a01b031681565b6000546001600160a01b031661033f565b60075461033f906001600160a01b031681565b61049e6104993660046142fd565b6112fc565b60408051938452602084019290925290820152606001610274565b600e5461033f906001600160a01b031681565b6103db6104da36600461400b565b611608565b6103db6104ed36600461424b565b6116dd565b60035461033f906001600160a01b031681565b61026a61051336600461400b565b611b9c565b60085461033f906001600160a01b031681565b600b5461033f906001600160a01b031681565b61026a61054c36600461400b565b60116020526000908152604090205481565b600c5461033f906001600160a01b031681565b60015461033f906001600160a01b031681565b6103db6105923660046142e0565b611bbd565b61033f7f000000000000000000000000000000000000000000000000000000000000000081565b600a5461033f906001600160a01b031681565b61026a6105df366004614347565b611c9c565b61060b7f000000000000000000000000000000000000000000000000000000000000000081565b6040516102749190614408565b60008160200151601e541461062f57506000919050565b600061063e8360000151611d15565b9050600061064b82611d5c565b60008151811061065d5761065d61441b565b60200260200101519050600061067283611eb0565b6000815181106106845761068461441b565b60200260200101519050600061069861201e565b6106b7576106a86012600a61452b565b6106b29083614537565b6106b9565b815b905060006106d6826012600201546106d19190614537565b6120a1565b60165490915084108015906106ed57506017548411155b80156106fa575060155481105b979650505050505050565b6018546000908190816107166120c1565b8551600090815260116020526040812054919250908190156107815786516000908152601160205260408120546107559061075090611d15565b6121a9565b6000815181106107675761076761441b565b602002602001015190508060800151915080606001519250505b60006107a688604001518960200151866000015188876107a1919061458f565b612428565b905060006107c76012600b01546107c18b6040015189612492565b906124b5565b6107d1908461458f565b90506107e66107e083836124d7565b846124d7565b96506107f283886145a7565b9750505050505050915091565b6000546001600160a01b0316331461085e5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632728f3336040518163ffffffff1660e01b81526004016101006040518083038186803b1580156108ba57600080fd5b505afa1580156108ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f2919061460b565b975050505050505050801561096f5760405162461bcd60e51b815260206004820152602960248201527f63616e6e6f74206368616e676520737472617465677920696620726f756e642060448201527f69732061637469766500000000000000000000000000000000000000000000006064820152608401610855565b508051601255602081015160135560408101516014556060810151601555608081015160165560a081015160175560c081015160185560e0810151601955610100810151601a55610120810151601b55610140810151601c556101600151601d55565b6000546001600160a01b03163314610a2c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b610a38848484846116dd565b600a5460405163095ea7b360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260001960248301529091169063095ea7b390604401602060405180830381600087803b158015610aa757600080fd5b505af1158015610abb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610adf919061469d565b50600b5460405163095ea7b360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260001960248301529091169063095ea7b390604401602060405180830381600087803b158015610b4f57600080fd5b505af1158015610b63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b87919061469d565b50610b906124ed565b610ba557600a546001600160a01b0316610bb2565b600b546001600160a01b03165b600e80546001600160a01b0319166001600160a01b039290921691909117905550505050565b6000546001600160a01b03163314610c325760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b600260009054906101000a90046001600160a01b03166001600160a01b0316633535c97b6040518163ffffffff1660e01b815260040160206040518083038186803b158015610c8057600080fd5b505afa158015610c94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb891906146c3565b60025460405163447fbc6360e01b81526001600160a01b03918216600482015291169063447fbc6390602401600060405180830381600087803b158015610cfe57600080fd5b505af1158015610d12573d6000803e3d6000fd5b50505050565b600080610d2483612534565b6012549091508110801590610d3b57506013548111155b9392505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610da75760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b6000610db561075085611d15565b600081518110610dc757610dc761441b565b602002602001015190506000610de8610de38360200151611d15565b612590565b600081518110610dfa57610dfa61441b565b602002602001015190508460116000846020015181526020019081526020016000205414610e6a5760405162461bcd60e51b815260206004820152601260248201527f696e76616c696420706f736974696f6e496400000000000000000000000000006044820152606401610855565b610e7d8282604001518360200151611c9c565b841115610ef25760405162461bcd60e51b815260206004820152602360248201527f616d6f756e74206578636565647320616c6c6f77656420636c6f736520616d6f60448201527f756e7400000000000000000000000000000000000000000000000000000000006064820152608401610855565b6000610f0982601260050154601260060154612736565b9050610f1983866000848861278f565b610f216124ed565b1561105157600b546040516370a0823160e01b81523060048201526000916001600160a01b0316906370a082319060240160206040518083038186803b158015610f6a57600080fd5b505afa158015610f7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa291906146e0565b600b5460405163a9059cbb60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820184905292935091169063a9059cbb90604401602060405180830381600087803b15801561101257600080fd5b505af1158015611026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104a919061469d565b50506110f9565b600a5460405163a9059cbb60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018890529091169063a9059cbb90604401602060405180830381600087803b1580156110bf57600080fd5b505af11580156110d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110f7919061469d565b505b505050505050565b6000546001600160a01b0316331461115b5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b61116560006128c3565b565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146111cc5760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b60005b60105481101561127b576000601082815481106111ee576111ee61441b565b90600052602060002001549050600061121c6107506011600085815260200190815260200160002054611d15565b60008151811061122e5761122e61441b565b6020026020010151905061124c81826060015160006000198861278f565b506000908152601160209081526040808320839055600f90915281205580611273816146f9565b9150506111cf565b50611284612913565b50565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146112ec5760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b6112f4612913565b611165612c98565b60008080336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146113655760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b6019546000868152600f602052604090205442916113829161458f565b11156113d05760405162461bcd60e51b815260206004820152601c60248201527f6d696e2074696d6520696e74657276616c206e6f7420706173736564000000006044820152606401610855565b6113d985612dbf565b6114255760405162461bcd60e51b815260206004820152601560248201527f766f6c2076617269616e636520657863656564656400000000000000000000006044820152606401610855565b6000611433610de387611d15565b6000815181106114455761144561441b565b6020026020010151905061145881610618565b6114a45760405162461bcd60e51b815260206004820152600e60248201527f696e76616c696420737472696b650000000000000000000000000000000000006044820152606401610855565b60006114af82610705565b600e546040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301523060248301526044820185905293965091935091909116906323b872dd90606401602060405180830381600087803b15801561154357600080fd5b505af1158015611557573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061157b919061469d565b6115ed5760405162461bcd60e51b815260206004820152602560248201527f636f6c6c61746572616c207472616e736665722066726f6d207661756c74206660448201527f61696c65640000000000000000000000000000000000000000000000000000006064820152608401610855565b6115f8828288612e32565b9098909750929550919350505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461166d5760405162461bcd60e51b815260206004820152600a6024820152691bdb9b1e4815985d5b1d60b21b6044820152606401610855565b600061167882612fa7565b90506116878160200151610d18565b6116d35760405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420626f617264000000000000000000000000000000000000006044820152606401610855565b60200151601e5550565b6000546001600160a01b031633146117375760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b600a546001600160a01b0316156117d257600a5460035460405163095ea7b360e01b81526001600160a01b0391821660048201526000602482015291169063095ea7b390604401602060405180830381600087803b15801561179857600080fd5b505af11580156117ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d0919061469d565b505b600b546001600160a01b03161561186d57600b5460035460405163095ea7b360e01b81526001600160a01b0391821660048201526000602482015291169063095ea7b390604401602060405180830381600087803b15801561183357600080fd5b505af1158015611847573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061186b919061469d565b505b600380546001600160a01b038581166001600160a01b0319928316179092556001805492871692909116821790556040517f7f2e06000000000000000000000000000000000000000000000000000000000081527f53594e5448455449585f414441505445520000000000000000000000000000006004820152637f2e06009060240160206040518083038186803b15801561190857600080fd5b505afa15801561191c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194091906146c3565b600280546001600160a01b0319166001600160a01b039290921691909117905561196861309f565b600c80546001600160a01b038085166001600160a01b031992831617909255600d80548484169216919091179055600254604080517f3535c97b00000000000000000000000000000000000000000000000000000000815290519190921691633535c97b916004808301926020929190829003018186803b1580156119ec57600080fd5b505afa158015611a00573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a2491906146c3565b60025460405163447fbc6360e01b81526001600160a01b03918216600482015291169063447fbc6390602401600060405180830381600087803b158015611a6a57600080fd5b505af1158015611a7e573d6000803e3d6000fd5b5050600a5460035460405163095ea7b360e01b81526001600160a01b03918216600482015260001960248201529116925063095ea7b39150604401602060405180830381600087803b158015611ad357600080fd5b505af1158015611ae7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b0b919061469d565b50600b5460035460405163095ea7b360e01b81526001600160a01b039182166004820152600019602482015291169063095ea7b390604401602060405180830381600087803b158015611b5d57600080fd5b505af1158015611b71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b95919061469d565b5050505050565b60108181548110611bac57600080fd5b600091825260209091200154905081565b6000546001600160a01b03163314611c175760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610855565b6001600160a01b038116611c935760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610855565b611284816128c3565b600080611ca76120c1565b90506000611cc385858460000151670de0b6b3a7640000612428565b9050611cdc8660600151826124b590919063ffffffff16565b866080015110611ced576000611d0b565b6080860151611cfc90826131ee565b8660600151611d0b91906145a7565b9695505050505050565b604080516001808252818301909252606091602080830190803683370190505090508181600081518110611d4b57611d4b61441b565b602002602001018181525050919050565b80516060908067ffffffffffffffff811115611d7a57611d7a614024565b604051908082528060200260200182016040528015611da3578160200160208202803683370190505b50915060005b81811015611ea957600354845160009182916001600160a01b039091169063c4c4a0d090889086908110611ddf57611ddf61441b565b60200260200101516040518263ffffffff1660e01b8152600401611e0591815260200190565b60006040518083038186803b158015611e1d57600080fd5b505afa158015611e31573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611e599190810190614881565b91509150611e78826040015182604001516124b590919063ffffffff16565b858481518110611e8a57611e8a61441b565b602002602001018181525050505080611ea2906146f9565b9050611da9565b5050919050565b80516060908067ffffffffffffffff811115611ece57611ece614024565b604051908082528060200260200182016040528015611ef7578160200160208202803683370190505b50915060005b81811015611ea9576000611f29858381518110611f1c57611f1c61441b565b6020026020010151613207565b604080517f8d31f3aa0000000000000000000000000000000000000000000000000000000081528251600482015260208301516024820152908201516044820152606082015160648201526080820151608482015290915073__$c0a17acec7091fec39628aa0eae1394872$__90638d31f3aa9060a401604080518083038186803b158015611fb757600080fd5b505af4158015611fcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fef91906148d2565b508483815181106120025761200261441b565b602090810291909101015250612017816146f9565b9050611efd565b600060047f00000000000000000000000000000000000000000000000000000000000000006004811115612054576120546143d4565b1480612091575060017f0000000000000000000000000000000000000000000000000000000000000000600481111561208f5761208f6143d4565b145b61209b5750600190565b50600090565b6000808212156120b9576120b4826148f6565b6120bb565b815b92915050565b6120e560405180606001604052806000815260200160008152602001600081525090565b6002546003546040517fcfbe7f440000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152600092919091169063cfbe7f449060240160a06040518083038186803b15801561214a57600080fd5b505afa15801561215e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121829190614913565b60408051606080820183528351825283015160208201526080909201519082015292915050565b600480546040517f23d354770000000000000000000000000000000000000000000000000000000081526060926000926001600160a01b0316916323d35477916121f591879101614963565b60006040518083038186803b15801561220d57600080fd5b505afa158015612221573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261224991908101906149a7565b805190915060008167ffffffffffffffff81111561226957612269614024565b6040519080825280602002602001820160405280156122a257816020015b61228f613f27565b8152602001906001900390816122875790505b50905060005b8281101561241f576040518060c001604052808583815181106122cd576122cd61441b565b60200260200101516000015181526020018583815181106122f0576122f061441b565b60200260200101516020015181526020018583815181106123135761231361441b565b6020026020010151604001516004811115612330576123306143d4565b6004811115612341576123416143d4565b6004811115612352576123526143d4565b81526020018583815181106123695761236961441b565b602002602001015160600151815260200185838151811061238c5761238c61441b565b60200260200101516080015181526020018583815181106123af576123af61441b565b602002602001015160a0015160058111156123cc576123cc6143d4565b60058111156123dd576123dd6143d4565b60058111156123ee576123ee6143d4565b8152508282815181106124035761240361441b565b602002602001018190525080612418906146f9565b90506122a8565b50949350505050565b6000806124587f00000000000000000000000000000000000000000000000000000000000000008787878761345b565b601c5490915060009061246c9083906124b5565b9050600061247a8886612492565b90506124868282613506565b98975050505050505050565b600061249c6124ed565b6124af576124aa82846124b5565b610d3b565b50919050565b60006124c36012600a61452b565b6124cd8385614a95565b610d3b9190614ab4565b60008183116124e65781610d3b565b5090919050565b600060027f00000000000000000000000000000000000000000000000000000000000000006004811115612523576125236143d4565b1461252e5750600090565b50600190565b6000814211156125865760405162461bcd60e51b815260206004820152601160248201527f74696d657374616d7020657870697265640000000000000000000000000000006044820152606401610855565b6120bb42836145a7565b80516060908067ffffffffffffffff8111156125ae576125ae614024565b60405190808252806020026020018201604052801561261157816020015b6125fe6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b8152602001906001900390816125cc5790505b50915060005b81811015611ea957600354845160009182916001600160a01b039091169063c4c4a0d09088908690811061264d5761264d61441b565b60200260200101516040518263ffffffff1660e01b815260040161267391815260200190565b60006040518083038186803b15801561268b57600080fd5b505afa15801561269f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526126c79190810190614881565b915091506040518060a001604052808360000151815260200182602001518152602001836020015181526020018360400151815260200182604001518152508584815181106127185761271861441b565b602002602001018190525050508061272f906146f9565b9050612617565b6000806127416120c1565b90506000806127666127568860200151612534565b8785600001518a60400151613515565b9150915061277261201e565b6127855761278081866124b5565b6106fa565b6106fa82866124b5565b6000848660600151146127a65785608001516127a9565b60005b905060006040518061012001604052808860200151815260200188600001518152602001600381526020017f00000000000000000000000000000000000000000000000000000000000000006004811115612806576128066143d4565b8152602001878152602001838152602001868152602001858152602001846001600160a01b03168152509050600061283d8261369f565b905084816020015111156128b95760405162461bcd60e51b815260206004820152602a60248201527f7072656d69756d20706169642069732061626f7665206d61782065787065637460448201527f6564207072656d69756d000000000000000000000000000000000000000000006064820152608401610855565b5050505050505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600061291d6120c1565b600a546040516370a0823160e01b81523060048201529192506000916001600160a01b03909116906370a082319060240160206040518083038186803b15801561296657600080fd5b505afa15801561297a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061299e91906146e0565b90506129a86124ed565b15612b9657600b546040516370a0823160e01b81523060048201526000916001600160a01b0316906370a082319060240160206040518083038186803b1580156129f157600080fd5b505afa158015612a05573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a2991906146e0565b6040840151909150600090612a5b90612a446012600a61452b565b612a4e91906145a7565b85516107c19086906131ee565b90506000612a6984836136ff565b600b549091506001600160a01b031663a9059cbb7f0000000000000000000000000000000000000000000000000000000000000000612aa8848761458f565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b1681526001600160a01b0390921660048301526024820152604401602060405180830381600087803b158015612b0657600080fd5b505af1158015612b1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b3e919061469d565b611b955760405162461bcd60e51b8152602060048201526024808201527f6661696c656420746f2072657475726e2066756e64732066726f6d20737472616044820152637465677960e01b6064820152608401610855565b600a5460405163a9059cbb60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018490529091169063a9059cbb90604401602060405180830381600087803b158015612c0457600080fd5b505af1158015612c18573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c3c919061469d565b612c945760405162461bcd60e51b8152602060048201526024808201527f6661696c656420746f2072657475726e2066756e64732066726f6d20737472616044820152637465677960e01b6064820152608401610855565b5050565b601054156111655760005b601054811015612db257600060108281548110612cc257612cc261441b565b906000526020600020015490506000612cf06107506011600085815260200190815260200160002054611d15565b600081518110612d0257612d0261441b565b6020026020010151905060016005811115612d1f57612d1f6143d4565b8160a001516005811115612d3557612d356143d4565b1415612d835760405162461bcd60e51b815260206004820152601c60248201527f63616e6e6f7420636c6561722061637469766520706f736974696f6e000000006044820152606401610855565b506000908152601160209081526040808320839055600f90915281205580612daa816146f9565b915050612ca3565b5061116560106000613f7e565b600080612dd1836012600901546137f1565b90506000612de6612de185611d15565b611d5c565b600081518110612df857612df861441b565b60200260200101519050600081831015612e1b57612e1683836145a7565b612e25565b612e2582846145a7565b601a541195945050505050565b6000806000612e4c86601260040154601260060154612736565b90506000612ef560405180610120016040528089600001518152602001601160008b600001518152602001908152602001600020548152602001600381526020017f00000000000000000000000000000000000000000000000000000000000000006004811115612ebf57612ebf6143d4565b815260200160126006015481526020018881526020018481526020016000198152602001876001600160a01b031681525061388e565b87516000908152600f6020526040902042905587518151919250612f1891613a3d565b8181602001511015612f925760405162461bcd60e51b815260206004820152602e60248201527f7072656d69756d2072656365697665642069732062656c6f77206d696e20657860448201527f706563746564207072656d69756d0000000000000000000000000000000000006064820152608401610855565b80516020909101519097909650945050505050565b612fd26040518060800160405280600081526020016000815260200160008152602001606081525090565b6003546040517f16a54f50000000000000000000000000000000000000000000000000000000008152600481018490526000916001600160a01b0316906316a54f509060240160006040518083038186803b15801561303057600080fd5b505afa158015613044573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261306c9190810190614ad6565b60408051608080820183528351825260208085015190830152828401519282019290925291015160608201529392505050565b6001546003546040517fc4158a510000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152600092919091169063c4158a51906024016101606040518083038186803b15801561310557600080fd5b505afa158015613119573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061313d9190614b13565b8051600580546001600160a01b03199081166001600160a01b03938416179091556040830151600980548316918416919091179055608083015160088054831691841691909117905560a083015160048054831691841691909117905560e0830151600680548316918416919091179055610100830151600780548316918416919091179055610120830151600a8054831691841691909117905561014090920151600b8054909316911617905550565b6000816131fd6012600a61452b565b6124cd9085614a95565b6132396040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b6003546040517fc4c4a0d00000000000000000000000000000000000000000000000000000000081526004810184905260009182916001600160a01b039091169063c4c4a0d09060240160006040518083038186803b15801561329b57600080fd5b505afa1580156132af573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526132d79190810190614881565b915091506040518060a001604052804283602001516132f691906145a7565b8152602001613316846040015184604001516124b590919063ffffffff16565b81526002546003546040517f7dbae6480000000000000000000000000000000000000000000000000000000081526001600160a01b039182166004820152602090930192911690637dbae6489060240160206040518083038186803b15801561337e57600080fd5b505afa158015613392573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133b691906146e0565b815260200183602001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561341457600080fd5b505afa158015613428573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061344c9190614bed565b61012001519052949350505050565b6009546000906001600160a01b031663a57ce682876004811115613481576134816143d4565b6004811115613492576134926143d4565b878787876040518663ffffffff1660e01b81526004016134b6959493929190614c74565b60206040518083038186803b1580156134ce57600080fd5b505afa1580156134e2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d0b91906146e0565b60008183106124e65781610d3b565b60008060006040518060a00160405280888152602001878152602001868152602001858152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b15801561358c57600080fd5b505afa1580156135a0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135c49190614bed565b61012001519052604080517fb6e62e590000000000000000000000000000000000000000000000000000000081528251600482015260208301516024820152908201516044820152606082015160648201526080820151608482015290915073__$c0a17acec7091fec39628aa0eae1394872$__9063b6e62e599060a401604080518083038186803b15801561365957600080fd5b505af415801561366d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061369191906148d2565b909890975095505050505050565b6136c360405180606001604052806000815260200160008152602001600081525090565b81516136ce90613a93565b1580156136e3575081516136e190613b44565b155b156136f1576120bb82613bdc565b6120bb82613c1d565b919050565b6002546003546040517fae58cf0b0000000000000000000000000000000000000000000000000000000081526001600160a01b03918216600482015260248101859052600092919091169063ae58cf0b90604401602060405180830381600087803b15801561376d57600080fd5b505af1158015613781573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137a591906146e0565b9050818110156120bb576040517ff125dbc40000000000000000000000000000000000000000000000000000000081523060048201526024810183905260448101829052606401610855565b6007546040517f39a427f100000000000000000000000000000000000000000000000000000000815260048101849052602481018390526000916001600160a01b0316906339a427f19060440160206040518083038186803b15801561385657600080fd5b505afa15801561386a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3b91906146e0565b6138b260405180606001604052806000815260200160008152602001600081525090565b6003546000906001600160a01b03166237f2bc6138ce85613c5a565b6040518263ffffffff1660e01b81526004016138ea9190614ca2565b606060405180830381600087803b15801561390457600080fd5b505af1158015613918573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061393c9190614d06565b6101008401519091506001600160a01b031615613a1757600d546003546101008501516001600160a01b039283169263a4ed578192169061397c87613c5a565b60800151602086015160408088015190517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b1681526001600160a01b03958616600482015294909316602485015260448401919091526064830152608482015260a401600060405180830381600087803b1580156139fe57600080fd5b505af1158015613a12573d6000803e3d6000fd5b505050505b604080516060810182528251815260208084015190820152918101519082015292915050565b600082815260116020526040902054612c94576000828152601160205260408120919091556010805460018101825591527f1b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae6720155565b600080613a9e613cf6565b60408051600180825281830190925291925060009190602080830190803683370190505090508381600081518110613ad857613ad861441b565b6020026020010181815250506000613aef82611eb0565b600081518110613b0157613b0161441b565b602002602001015190508260600151601260ff16600a613b21919061452b565b613b2b9190614537565b811380613b3b5750826060015181125b95945050505050565b600080613b4f613cf6565b60408051600180825281830190925291925060009190602080830190803683370190505090508381600081518110613b8957613b8961441b565b6020026020010181815250506000613ba082612590565b600081518110613bb257613bb261441b565b602002602001015190508260800151428260200151613bd191906145a7565b111595945050505050565b613c0060405180606001604052806000815260200160008152602001600081525090565b6003546000906001600160a01b03166392b4632c6138ce85613c5a565b613c4160405180606001604052806000815260200160008152602001600081525090565b6003546000906001600160a01b031663e4e83e3d6138ce855b613c62613f9c565b60405180610100016040528083600001518152602001836020015181526020018360400151815260200183606001516004811115613ca257613ca26143d4565b6004811115613cb357613cb36143d4565b6004811115613cc457613cc46143d4565b8152602001836080015181526020018360a0015181526020018360c0015181526020018360e001518152509050919050565b613d2f6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600854604080517fda53763100000000000000000000000000000000000000000000000000000000815290516000926001600160a01b03169163da53763191600480830192610120929190829003018186803b158015613d8e57600080fd5b505afa158015613da2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613dc69190614d62565b90506000600860009054906101000a90046001600160a01b03166001600160a01b031663ffae4b366040518163ffffffff1660e01b81526004016101806040518083038186803b158015613e1957600080fd5b505afa158015613e2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613e519190614d7f565b90506040518060c001604052808360e0015181526020018361010001518152602001600960009054906101000a90046001600160a01b03166001600160a01b031663f369f2ac6040518163ffffffff1660e01b81526004016101406040518083038186803b158015613ec257600080fd5b505afa158015613ed6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613efa9190614bed565b61012001518152602001826000015181526020018260400151815260200182602001518152509250505090565b6040518060c00160405280600081526020016000815260200160006004811115613f5357613f536143d4565b8152602001600081526020016000815260200160006005811115613f7957613f796143d4565b905290565b50805460008255906000526020600020908101906112849190613ff2565b60405180610100016040528060008152602001600081526020016000815260200160006004811115613fd057613fd06143d4565b8152602001600081526020016000815260200160008152602001600081525090565b5b808211156140075760008155600101613ff3565b5090565b60006020828403121561401d57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff8111828210171561405d5761405d614024565b60405290565b604051610180810167ffffffffffffffff8111828210171561405d5761405d614024565b60405160c0810167ffffffffffffffff8111828210171561405d5761405d614024565b604051610120810167ffffffffffffffff8111828210171561405d5761405d614024565b604051610160810167ffffffffffffffff8111828210171561405d5761405d614024565b604051610140810167ffffffffffffffff8111828210171561405d5761405d614024565b604051601f8201601f1916810167ffffffffffffffff8111828210171561413f5761413f614024565b604052919050565b600060a0828403121561415957600080fd5b61416161403a565b82358152602083013560208201526040830135604082015260608301356060820152608083013560808201528091505092915050565b600061018082840312156141aa57600080fd5b6141b2614063565b823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e08201526101008084013581830152506101208084013581830152506101408084013581830152506101608084013581830152508091505092915050565b6001600160a01b038116811461128457600080fd5b6000806000806080858703121561426157600080fd5b843561426c81614236565b9350602085013561427c81614236565b9250604085013561428c81614236565b9150606085013561429c81614236565b939692955090935050565b6000806000606084860312156142bc57600080fd5b833592506020840135915060408401356142d581614236565b809150509250925092565b6000602082840312156142f257600080fd5b8135610d3b81614236565b6000806040838503121561431057600080fd5b82359150602083013561432281614236565b809150509250929050565b6005811061128457600080fd5b6006811061128457600080fd5b600080600083850361010081121561435e57600080fd5b60c081121561436c57600080fd5b50614375614087565b843581526020850135602082015260408501356143918161432d565b80604083015250606085013560608201526080850135608082015260a08501356143ba8161433a565b60a08201529560c0850135955060e0909401359392505050565b634e487b7160e01b600052602160045260246000fd5b6005811061128457634e487b7160e01b600052602160045260246000fd5b60208101614415836143ea565b91905290565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600181815b8085111561448257816000190482111561446857614468614431565b8085161561447557918102915b93841c939080029061444c565b509250929050565b600082614499575060016120bb565b816144a6575060006120bb565b81600181146144bc57600281146144c6576144e2565b60019150506120bb565b60ff8411156144d7576144d7614431565b50506001821b6120bb565b5060208310610133831016604e8410600b8410161715614505575081810a6120bb565b61450f8383614447565b806000190482111561452357614523614431565b029392505050565b6000610d3b838361448a565b600080831283600160ff1b0183128115161561455557614555614431565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01831381161561458957614589614431565b50500390565b600082198211156145a2576145a2614431565b500190565b6000828210156145b9576145b9614431565b500390565b80516cffffffffffffffffffffffffff811681146136fa57600080fd5b80516fffffffffffffffffffffffffffffffff811681146136fa57600080fd5b805180151581146136fa57600080fd5b600080600080600080600080610100898b03121561462857600080fd5b885161ffff8116811461463a57600080fd5b975061464860208a016145be565b965061465660408a016145be565b95506060890151945061466b60808a016145db565b935061467960a08a016145db565b925060c0890151915061468e60e08a016145fb565b90509295985092959890939650565b6000602082840312156146af57600080fd5b610d3b826145fb565b80516136fa81614236565b6000602082840312156146d557600080fd5b8151610d3b81614236565b6000602082840312156146f257600080fd5b5051919050565b600060001982141561470d5761470d614431565b5060010190565b6000610120828403121561472757600080fd5b61472f6140aa565b9050815181526020820151602082015260408201516040820152606082015160608201526080820151608082015260a082015160a082015260c082015160c082015260e082015160e082015261010080830151818301525092915050565b600067ffffffffffffffff8211156147a7576147a7614024565b5060051b60200190565b600060a082840312156147c357600080fd5b6147cb61403a565b90508151815260208083015181830152604083015160408301526147f1606084016145fb565b6060830152608083015167ffffffffffffffff81111561481057600080fd5b8301601f8101851361482157600080fd5b805161483461482f8261478d565b614116565b81815260059190911b8201830190838101908783111561485357600080fd5b928401925b8284101561487157835182529284019290840190614858565b6080860152509295945050505050565b600080610140838503121561489557600080fd5b61489f8484614714565b915061012083015167ffffffffffffffff8111156148bc57600080fd5b6148c8858286016147b1565b9150509250929050565b600080604083850312156148e557600080fd5b505080516020909101519092909150565b6000600160ff1b82141561490c5761490c614431565b5060000390565b600060a0828403121561492557600080fd5b61492d61403a565b82518152602083015160208201526040830151604082015260608301516060820152608083015160808201528091505092915050565b6020808252825182820181905260009190848201906040850190845b8181101561499b5783518352928401929184019160010161497f565b50909695505050505050565b600060208083850312156149ba57600080fd5b825167ffffffffffffffff8111156149d157600080fd5b8301601f810185136149e257600080fd5b80516149f061482f8261478d565b81815260c09182028301840191848201919088841115614a0f57600080fd5b938501935b83851015614a895780858a031215614a2c5760008081fd5b614a34614087565b855181528686015187820152604080870151614a4f8161432d565b90820152606086810151908201526080808701519082015260a080870151614a768161433a565b9082015283529384019391850191614a14565b50979650505050505050565b6000816000190483118215151615614aaf57614aaf614431565b500290565b600082614ad157634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215614ae857600080fd5b815167ffffffffffffffff811115614aff57600080fd5b614b0b848285016147b1565b949350505050565b60006101608284031215614b2657600080fd5b614b2e6140ce565b614b37836146b8565b8152614b45602084016146b8565b6020820152614b56604084016146b8565b6040820152614b67606084016146b8565b6060820152614b78608084016146b8565b6080820152614b8960a084016146b8565b60a0820152614b9a60c084016146b8565b60c0820152614bab60e084016146b8565b60e0820152610100614bbe8185016146b8565b90820152610120614bd08482016146b8565b90820152610140614be28482016146b8565b908201529392505050565b60006101408284031215614c0057600080fd5b614c086140f2565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015181830152506101208084015181830152508091505092915050565b60a08101614c81876143ea565b95815260208101949094526040840192909252606083015260809091015290565b6000610100820190508251825260208301516020830152604083015160408301526060830151614cd1816143ea565b806060840152506080830151608083015260a083015160a083015260c083015160c083015260e083015160e083015292915050565b600060608284031215614d1857600080fd5b6040516060810181811067ffffffffffffffff82111715614d3b57614d3b614024565b80604052508251815260208301516020820152604083015160408201528091505092915050565b60006101208284031215614d7557600080fd5b610d3b8383614714565b60006101808284031215614d9257600080fd5b614d9a614063565b825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e0820152610100808401518183015250610120808401518183015250610140808401518183015250610160614be28185016145fb56fea26469706673582212209caa9bf23dbba5652e9036ea01bd0da8675b2b2d11708304629e93cbea716d6e64736f6c63430008090033",
  "libraries": {
    "BlackScholes": "0x3AE81479aBEeA6b451e070F955eDDFf1Bc70C00b"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_isValidExpiry(uint256)": {
        "details": "check if the expiry of the board is valid according to the strategy"
      },
      "doTrade(uint256,address)": {
        "details": "the vault should pass in a strike id, and the strategy would verify if the strike is valid on-chain.",
        "params": {
          "lyraRewardRecipient": "address to receive trading reward. This need to be whitelisted",
          "strikeId": "lyra strikeId to trade"
        },
        "returns": {
          "positionId": "positionId",
          "premiumReceived": "premiumReceived"
        }
      },
      "emergencyCloseAll(address)": {
        "details": "close all outstanding positions regardless of collat and send funds back to vault"
      },
      "getAllowedCloseAmount((uint256,uint256,uint8,uint256,uint256,uint8),uint256,uint256)": {
        "details": "calculates the position amount required to stay above the buffer collateral"
      },
      "getRequiredCollateral((uint256,uint256,uint256,uint256,uint256))": {
        "details": "calculate required collateral to add in the next trade. sell size is fixed as strategyDetail.size only add collateral if the additional sell will make the position out of buffer range never remove collateral from an existing position"
      },
      "isValidStrike((uint256,uint256,uint256,uint256,uint256))": {
        "details": "verify if the strike is valid for the strategy",
        "returns": {
          "isValid": "true if vol is withint [minVol, maxVol] and delta is within targetDelta +- maxDeltaGap"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "reducePosition(uint256,uint256,address)": {
        "details": "use premium in strategy to reduce position size if collateral ratio is out of range"
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "returnFundsAndClearStrikes()": {
        "details": "convert premium in quote asset into collateral asset and send it back to the vault."
      },
      "setBoard(uint256)": {
        "details": "set the board id that will be traded for the next round",
        "params": {
          "boardId": "lyra board Id."
        }
      },
      "setLyraAddresses(address,address,address,address)": {
        "details": "Assigns all lyra contracts",
        "params": {
          "_curveSwap": "Curve pool address for swapping sUSD and other stables via `exchange_with_best_rate`",
          "_feeCounter": "Fee counter addressu used to determine Lyra trading rewards",
          "_lyraRegistry": "LyraRegistry address which holds latest market and global addressess",
          "_optionMarket": "OptionMarket address"
        }
      },
      "setStrategyDetail((uint256,uint256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "details": "update the strategy detail for the new round."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "doTrade(uint256,address)": {
        "notice": "sell a fix aomunt of options and collect premium"
      },
      "updateDelegateApproval()": {
        "notice": "In case of an update to the synthetix contract that revokes the approval"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 51422,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 24756,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "lyraRegistry",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ILyraRegistry)18180"
      },
      {
        "astId": 24759,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "synthetixAdapter",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(ISynthetixAdapter)20418"
      },
      {
        "astId": 24762,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "optionMarket",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(IOptionMarket)19123"
      },
      {
        "astId": 24765,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "optionToken",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(IOptionToken)19859"
      },
      {
        "astId": 24768,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "liquidityPool",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(ILiquidityPool)18066"
      },
      {
        "astId": 24771,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "shortCollateral",
        "offset": 0,
        "slot": "6",
        "type": "t_contract(IShortCollateral)19998"
      },
      {
        "astId": 24774,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "gwavOracle",
        "offset": 0,
        "slot": "7",
        "type": "t_contract(IGWAVOracle)17514"
      },
      {
        "astId": 24777,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "optionPricer",
        "offset": 0,
        "slot": "8",
        "type": "t_contract(IOptionMarketPricer)19452"
      },
      {
        "astId": 24780,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "greekCache",
        "offset": 0,
        "slot": "9",
        "type": "t_contract(IOptionGreekCache)18607"
      },
      {
        "astId": 24783,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "quoteAsset",
        "offset": 0,
        "slot": "10",
        "type": "t_contract(IERC20)52183"
      },
      {
        "astId": 24786,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "baseAsset",
        "offset": 0,
        "slot": "11",
        "type": "t_contract(IERC20)52183"
      },
      {
        "astId": 24789,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "curveSwap",
        "offset": 0,
        "slot": "12",
        "type": "t_contract(ICurve)17398"
      },
      {
        "astId": 24792,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "feeCounter",
        "offset": 0,
        "slot": "13",
        "type": "t_contract(BasicFeeCounter)23024"
      },
      {
        "astId": 42376,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "collateralAsset",
        "offset": 0,
        "slot": "14",
        "type": "t_contract(IERC20)37167"
      },
      {
        "astId": 42380,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "lastTradeTimestamp",
        "offset": 0,
        "slot": "15",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 42383,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "activeStrikeIds",
        "offset": 0,
        "slot": "16",
        "type": "t_array(t_uint256)dyn_storage"
      },
      {
        "astId": 42387,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "strikeToPositionId",
        "offset": 0,
        "slot": "17",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 41530,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "strategyDetail",
        "offset": 0,
        "slot": "18",
        "type": "t_struct(DeltaShortStrategyDetail)41527_storage"
      },
      {
        "astId": 41532,
        "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
        "label": "activeExpiry",
        "offset": 0,
        "slot": "30",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_contract(BasicFeeCounter)23024": {
        "encoding": "inplace",
        "label": "contract BasicFeeCounter",
        "numberOfBytes": "20"
      },
      "t_contract(ICurve)17398": {
        "encoding": "inplace",
        "label": "contract ICurve",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)37167": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)52183": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IGWAVOracle)17514": {
        "encoding": "inplace",
        "label": "contract IGWAVOracle",
        "numberOfBytes": "20"
      },
      "t_contract(ILiquidityPool)18066": {
        "encoding": "inplace",
        "label": "contract ILiquidityPool",
        "numberOfBytes": "20"
      },
      "t_contract(ILyraRegistry)18180": {
        "encoding": "inplace",
        "label": "contract ILyraRegistry",
        "numberOfBytes": "20"
      },
      "t_contract(IOptionGreekCache)18607": {
        "encoding": "inplace",
        "label": "contract IOptionGreekCache",
        "numberOfBytes": "20"
      },
      "t_contract(IOptionMarket)19123": {
        "encoding": "inplace",
        "label": "contract IOptionMarket",
        "numberOfBytes": "20"
      },
      "t_contract(IOptionMarketPricer)19452": {
        "encoding": "inplace",
        "label": "contract IOptionMarketPricer",
        "numberOfBytes": "20"
      },
      "t_contract(IOptionToken)19859": {
        "encoding": "inplace",
        "label": "contract IOptionToken",
        "numberOfBytes": "20"
      },
      "t_contract(IShortCollateral)19998": {
        "encoding": "inplace",
        "label": "contract IShortCollateral",
        "numberOfBytes": "20"
      },
      "t_contract(ISynthetixAdapter)20418": {
        "encoding": "inplace",
        "label": "contract ISynthetixAdapter",
        "numberOfBytes": "20"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(DeltaShortStrategyDetail)41527_storage": {
        "encoding": "inplace",
        "label": "struct DeltaShortStrategy.DeltaShortStrategyDetail",
        "members": [
          {
            "astId": 41504,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "minTimeToExpiry",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 41506,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxTimeToExpiry",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 41508,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "targetDelta",
            "offset": 0,
            "slot": "2",
            "type": "t_int256"
          },
          {
            "astId": 41510,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxDeltaGap",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 41512,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "minVol",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 41514,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxVol",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 41516,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "size",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 41518,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "minTradeInterval",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 41520,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "maxVolVariance",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 41522,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "gwavPeriod",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 41524,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "collatBuffer",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 41526,
            "contract": "contracts/strategies/DeltaShortStrategy.sol:DeltaShortStrategy",
            "label": "collatPercent",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "384"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}